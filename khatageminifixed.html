<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Digital Khata</title>
    <style>
        /* --- Base Styles & Fonts --- */
        :root {
            --primary-color: #006400; /* Dark Green */
            --secondary-color: #f4f4f4; /* Light Gray */
            --text-color: #333;
            --border-color: #ccc;
            --ledger-line-color: #e0e0e0;
            --ledger-bg-color: #fdfdfd;
            --danger-color: #dc3545;
            --success-color: #28a745;
            --font-handwritten: 'cursive', 'Segoe Script', 'Brush Script MT', sans-serif; /* Fallback fonts */
            --font-sans: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: var(--font-sans);
            background-color: var(--secondary-color);
            color: var(--text-color);
            line-height: 1.6;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            padding: 10px;
        }

        .container {
            max-width: 1000px;
            margin: 15px auto;
            padding: 15px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }

        h1, h2, h3 {
            color: var(--primary-color);
            margin-bottom: 15px;
            font-weight: 600;
        }

        h1 {
            text-align: center;
            font-size: 1.8em;
        }

        h2 {
           font-size: 1.5em;
        }

        h3 {
            font-size: 1.2em;
        }

        /* --- Ledger Paper Styling --- */
        .ledger-input,
        .ledger-textarea,
        .ledger-select {
            background-color: var(--ledger-bg-color);
            border: none;
            border-bottom: 1px solid var(--ledger-line-color);
            padding: 10px 5px 5px 5px;
            margin-bottom: 10px;
            width: 100%;
            font-family: var(--font-handwritten);
            font-size: 1.1em;
            line-height: 1.8; /* Simulate lines */
            background-image: linear-gradient(to bottom, transparent 95%, var(--ledger-line-color) 95%);
            background-size: 100% 1.8em; /* Match line-height */
            background-repeat: repeat-y;
            background-position: 0 5px; /* Adjust vertical position */
            resize: vertical; /* Allow textarea resize */
        }

        .ledger-textarea {
            min-height: 80px;
        }

        .ledger-input:focus,
        .ledger-textarea:focus,
        .ledger-select:focus {
            outline: none;
            border-bottom: 2px solid var(--primary-color);
        }

        /* --- Buttons --- */
        .btn {
            display: inline-block;
            padding: 10px 18px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 500;
            text-align: center;
            transition: background-color 0.3s ease, transform 0.1s ease;
            margin: 5px;
            text-decoration: none; /* For <a> tags styled as buttons */
            color: #fff; /* Default text color for buttons */
        }

        .btn:active {
            transform: scale(0.98);
        }

        .btn-primary {
            background-color: var(--primary-color);
            color: #fff;
        }
        .btn-primary:hover {
            background-color: #004d00; /* Darker Green */
        }

        .btn-secondary {
            background-color: #6c757d; /* Gray */
            color: #fff;
        }
        .btn-secondary:hover {
            background-color: #5a6268;
        }

        .btn-danger {
            background-color: var(--danger-color);
            color: #fff;
        }
        .btn-danger:hover {
            background-color: #c82333;
        }

        .btn-success {
            background-color: var(--success-color);
            color: #fff;
        }
        .btn-success:hover {
            background-color: #218838;
        }

        .btn-warning {
            background-color: #ffc107;
            color: #212529;
        }
        .btn-warning:hover {
            background-color: #e0a800;
        }

        .btn-icon {
            padding: 8px 10px;
            font-size: 0.9em;
        }

        /* --- Forms & Modals --- */
        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            font-family: var(--font-sans); /* Use standard font for labels */
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.5);
        }

        .modal-content {
            background-color: #fff;
            margin: 10% auto;
            padding: 25px;
            border-radius: 8px;
            max-width: 500px;
            width: 90%;
            position: relative;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .modal-close {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 1.8em;
            font-weight: bold;
            color: #aaa;
            cursor: pointer;
            line-height: 1;
        }
        .modal-close:hover,
        .modal-close:focus {
            color: #333;
        }

        /* --- Tables --- */
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            font-size: 0.95em;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .data-table thead {
            background-color: var(--primary-color);
            color: #fff;
        }

        .data-table th,
        .data-table td {
            padding: 10px 12px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }

        .data-table tbody tr:nth-child(even) {
            background-color: var(--ledger-bg-color);
        }

        .data-table tbody tr:hover {
            background-color: #e9e9e9;
        }

        .data-table td .btn {
            padding: 5px 8px;
            font-size: 0.85em;
            margin: 2px;
        }

        .balance-positive {
            color: var(--success-color);
            font-weight: bold;
        }
        .balance-negative {
            color: var(--danger-color);
            font-weight: bold;
        }

        /* --- Layout & Sections --- */
        .section {
            margin-bottom: 25px;
            padding: 15px;
            background: #fff;
            border-radius: 5px;
            border: 1px solid var(--border-color);
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
        }

        .section-header h2, .section-header h3 {
            margin-bottom: 0; /* Remove default margin */
        }

        .dashboard-summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .summary-card {
            background-color: var(--ledger-bg-color);
            padding: 15px;
            border-radius: 5px;
            border: 1px solid var(--border-color);
            text-align: center;
        }

        .summary-card h4 {
            margin-bottom: 8px;
            font-size: 1em;
            color: var(--primary-color);
        }

        .summary-card p {
            font-size: 1.3em;
            font-weight: bold;
        }

        #customer-details-view {
            display: none; /* Hidden by default */
        }

        /* --- Filters & Search --- */
        .filter-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            align-items: center; /* Align items vertically */
        }

        .filter-controls label {
            margin-bottom: 0; /* Remove bottom margin for inline labels */
            margin-right: 5px;
            font-family: var(--font-sans);
            font-weight: normal;
        }

        .filter-controls input[type="date"],
        .filter-controls input[type="text"],
        .filter-controls select {
             padding: 8px;
             border: 1px solid var(--border-color);
             border-radius: 4px;
             font-family: var(--font-sans);
             font-size: 0.95em;
             /* Remove ledger styles for filter inputs */
             background-image: none;
             background-color: #fff;
             line-height: normal;
        }

        /* --- Urdu Toggle --- */
        .language-toggle {
            position: absolute;
            top: 15px;
            right: 15px;
            display: flex;
            align-items: center;
        }

        .language-toggle label {
            margin: 0 5px 0 0;
            font-size: 0.9em;
            font-weight: normal;
        }

        /* --- Print Styles --- */
        @media print {
            body {
                padding: 0;
                background-color: #fff;
                font-size: 10pt; /* Adjust base font size for print */
            }

            .container {
                max-width: 100%;
                margin: 0;
                padding: 0;
                box-shadow: none;
                border-radius: 0;
            }

            .no-print,
            .modal,
            .btn,
            .filter-controls,
            .language-toggle,
            #add-customer-btn,
            #backup-restore-section,
            #customer-list-view h2 + div, /* Hide buttons in customer list header */
            #customer-details-view .section-header div:last-child, /* Hide buttons in details header */
            #transaction-form-modal,
            #customer-form-modal,
            #report-modal,
            #reminder-modal,
            #csv-export-btn,
            #print-report-btn,
            #send-reminder-btn,
            #back-to-list-btn,
            .modal-close,
            .data-table td:last-child, /* Hide action buttons column */
            .data-table th:last-child {
                display: none !important;
            }

            h1, h2, h3 {
                color: #000; /* Black for print */
                margin-bottom: 10px;
            }

            .section {
                border: none;
                padding: 0;
                margin-bottom: 15px;
                page-break-inside: avoid;
            }

            .data-table {
                box-shadow: none;
                font-size: 9pt; /* Smaller font for tables in print */
            }

            .data-table th, .data-table td {
                padding: 5px 8px;
                border: 1px solid #ccc; /* Add borders for clarity */
            }

            .data-table thead {
                background-color: #eee; /* Light gray header for print */
                color: #000;
            }

            .ledger-input, .ledger-textarea, .ledger-select {
                border-bottom: 1px solid #000;
                background-image: none; /* Remove lines in print */
                padding: 2px 0;
                font-size: 10pt;
            }

            #customer-details-view {
                display: block !important; /* Ensure details view is visible for printing report */
            }
            #customer-list-view {
                display: none; /* Hide list view when printing report */
            }

            #printable-report-content {
                display: block !important; /* Ensure report content is visible */
            }
             #printable-report-content h3 {
                 text-align: center;
             }
        }

        /* --- Responsive Design --- */
        @media (max-width: 768px) {
            body {
                padding: 5px;
            }
            .container {
                padding: 10px;
                margin: 10px auto;
            }
            h1 { font-size: 1.6em; }
            h2 { font-size: 1.3em; }
            h3 { font-size: 1.1em; }

            .btn {
                padding: 8px 12px;
                font-size: 0.9em;
                width: 100%; /* Make buttons full width */
                margin: 5px 0; /* Adjust margin */
            }
            .btn-icon {
                width: auto; /* Keep icon buttons smaller */
                padding: 6px 8px;
            }

            .section-header {
                flex-direction: column;
                align-items: flex-start;
            }
            .section-header div { /* Button container */
                 margin-top: 10px;
                 width: 100%;
                 display: flex;
                 flex-direction: column;
            }

            .filter-controls {
                flex-direction: column;
                align-items: stretch;
            }
            .filter-controls > * {
                 margin-bottom: 8px;
            }
            .filter-controls label {
                margin-bottom: 3px;
            }

            .data-table {
                font-size: 0.85em;
            }
            .data-table th, .data-table td {
                padding: 8px 6px;
                word-break: break-word; /* Prevent long words from breaking layout */
            }
            /* Hide less critical columns on small screens */
            .data-table .hide-mobile {
                display: none;
            }

            .modal-content {
                margin: 15% auto;
                width: 95%;
                padding: 20px;
            }

            .language-toggle {
                position: static; /* Position normally */
                margin: 10px 0;
                justify-content: flex-end;
            }
        }

         @media (max-width: 480px) {
            h1 { font-size: 1.4em; }
            .dashboard-summary {
                 grid-template-columns: 1fr; /* Stack summary cards */
            }
            .data-table {
                font-size: 0.8em;
            }
            .data-table th, .data-table td {
                padding: 6px 4px;
            }
            /* Consider hiding more columns if needed */
         }

         /* Style to apply Noto Nastaliq Urdu font */
        .urdu-font-force {
            font-family: 'Noto Nastaliq Urdu', serif !important;
        }

    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Nastaliq+Urdu&display=swap" rel="stylesheet">
</head>
<body>
    <div class="container">
        <div class="language-toggle no-print">
            <label for="language-switch" data-en="Language" data-ur="زبان">Language:</label>
            <select id="language-switch">
                <option value="en">English</option>
                <option value="ur">Urdu (اردو)</option>
            </select>
        </div>

        <h1 data-en="Digital Khata" data-ur="ڈیجیٹل کھاتہ">Digital Khata</h1>

        <div id="customer-list-view">
            <div class="section">
                <div class="section-header">
                    <h2 data-en="Dashboard" data-ur="ڈیش بورڈ">Dashboard</h2>
                </div>
                <div class="dashboard-summary">
                    <div class="summary-card">
                        <h4 data-en="Total Customers" data-ur="کل صارفین">Total Customers</h4>
                        <p id="total-customers">0</p>
                    </div>
                    <div class="summary-card">
                        <h4 data-en="Total Balance (Lena Hai)" data-ur="کل بیلنس (لینا ہے)">Total Balance (Lena Hai)</h4>
                        <p id="total-balance-positive" class="balance-positive">Rs 0.00</p>
                    </div>
                     <div class="summary-card">
                        <h4 data-en="Total Advance (Dena Hai)" data-ur="کل ایڈوانس (دینا ہے)">Total Advance (Dena Hai)</h4>
                        <p id="total-balance-negative" class="balance-negative">Rs 0.00</p>
                    </div>
                </div>
            </div>

            <div class="section">
                <div class="section-header">
                    <h2 data-en="Customers" data-ur="صارفین">Customers</h2>
                    <div>
                        <button id="add-customer-btn" class="btn btn-primary no-print" data-en="Add New Customer" data-ur="نیا صارف شامل کریں">Add New Customer</button>
                    </div>
                </div>
                 <div class="filter-controls no-print">
                     <input type="text" id="customer-search" placeholder="Search Customers..." data-en-placeholder="Search Customers..." data-ur-placeholder="صارفین تلاش کریں...">
                 </div>
                <div style="overflow-x: auto;"> <table class="data-table" id="customer-table">
                        <thead>
                            <tr>
                                <th data-en="Name" data-ur="نام">Name</th>
                                <th data-en="Phone" data-ur="فون" class="hide-mobile">Phone</th>
                                <th data-en="Balance" data-ur="بیلنس">Balance</th>
                                <th data-en="Actions" data-ur="کاروائیاں" class="no-print">Actions</th>
                            </tr>
                        </thead>
                        <tbody id="customer-table-body">
                            </tbody>
                    </table>
                </div>
            </div>

             <div id="backup-restore-section" class="section no-print">
                <h3 data-en="Backup & Restore" data-ur="بیک اپ اور بحال کریں">Backup & Restore</h3>
                <button id="backup-btn" class="btn btn-secondary" data-en="Backup Data (JSON)" data-ur="ڈیٹا بیک اپ (JSON)">Backup Data (JSON)</button>
                <label for="restore-file" class="btn btn-warning" data-en="Restore Data (JSON)" data-ur="ڈیٹا بحال کریں (JSON)">Restore Data (JSON)</label>
                <input type="file" id="restore-file" accept=".json" style="display: none;">
            </div>
        </div> <div id="customer-details-view">
            <div class="section">
                 <div class="section-header">
                    <h2 id="details-customer-name">Customer Details</h2> <div>
                        <button id="back-to-list-btn" class="btn btn-secondary no-print" data-en="Back to List" data-ur="فہرست پر واپس">Back to List</button>
                    </div>
                 </div>
                 <div id="customer-info">
                     </div>
            </div>

            <div class="section">
                <div class="section-header">
                    <h3 data-en="Transactions" data-ur="لین دین">Transactions</h3>
                     <div>
                        <button id="add-transaction-btn" class="btn btn-primary no-print" data-en="Add Transaction" data-ur="لین دین شامل کریں">Add Transaction</button>
                        <button id="send-reminder-btn" class="btn btn-warning no-print" data-en="Send Reminder" data-ur="یاد دہانی بھیجیں">Send Reminder</button>
                        <button id="print-report-btn" class="btn btn-success no-print" data-en="Print Report" data-ur="رپورٹ پرنٹ کریں">Print Report</button>
                         <button id="csv-export-btn" class="btn btn-info no-print" data-en="Export CSV" data-ur="CSV ایکسپورٹ کریں">Export CSV</button>
                    </div>
                </div>

                <div class="filter-controls no-print">
                    <label for="filter-start-date" data-en="From:" data-ur="سے:">From:</label>
                    <input type="date" id="filter-start-date">
                    <label for="filter-end-date" data-en="To:" data-ur="تک:">To:</label>
                    <input type="date" id="filter-end-date">
                    <input type="text" id="transaction-search" placeholder="Search Description..." data-en-placeholder="Search Description..." data-ur-placeholder="تفصیل تلاش کریں...">
                    <button id="apply-filters-btn" class="btn btn-primary btn-icon" data-en="Filter" data-ur="فلٹر کریں">Filter</button>
                    <button id="clear-filters-btn" class="btn btn-secondary btn-icon" data-en="Clear" data-ur="صاف کریں">Clear</button>
                </div>

                <div style="overflow-x: auto;"> <table class="data-table" id="transaction-table">
                        <thead>
                            <tr>
                                <th data-en="Date" data-ur="تاریخ">Date</th>
                                <th data-en="Type" data-ur="قسم">Type</th>
                                <th data-en="Description" data-ur="تفصیل" class="hide-mobile">Description</th>
                                <th data-en="Amount" data-ur="رقم">Amount</th>
                                <th data-en="Balance" data-ur="بیلنس">Balance</th>
                                </tr>
                        </thead>
                        <tbody id="transaction-table-body">
                            </tbody>
                    </table>
                </div>
                <div id="customer-balance-summary" style="text-align: right; margin-top: 15px; font-size: 1.1em; font-weight: bold;">
                    <span data-en="Current Balance:" data-ur="موجودہ بیلنس:">Current Balance:</span> <span id="details-current-balance">Rs 0.00</span>
                </div>
            </div>
        </div> <div id="printable-report-content" style="display: none;">
            <h3 data-en="Monthly Statement" data-ur="ماہانہ گوشوارہ">Monthly Statement</h3>
            <div id="report-customer-info"></div>
            <div id="report-period"></div>
            <table class="data-table" id="report-table">
                <thead>
                    <tr>
                        <th data-en="Date" data-ur="تاریخ">Date</th>
                        <th data-en="Type" data-ur="قسم">Type</th>
                        <th data-en="Description" data-ur="تفصیل">Description</th>
                        <th data-en="Udhaar (Debit)" data-ur="ادھار (لینا ہے)">Udhaar (Debit)</th>
                        <th data-en="Payment (Credit)" data-ur="وصولی (جمع)">Payment (Credit)</th>
                        <th data-en="Balance" data-ur="بیلنس">Balance</th>
                    </tr>
                </thead>
                <tbody id="report-table-body">
                    </tbody>
            </table>
            <div id="report-summary" style="margin-top: 15px; text-align: right; font-weight: bold;"></div>
        </div>

    </div> <div id="customer-form-modal" class="modal">
        <div class="modal-content">
            <span class="modal-close" onclick="closeModal('customer-form-modal')">&times;</span>
            <h3 id="customer-modal-title" data-en="Add New Customer" data-ur="نیا صارف شامل کریں">Add New Customer</h3>
            <form id="customer-form">
                <input type="hidden" id="customer-id"> <div class="form-group">
                    <label for="customer-name" data-en="Name" data-ur="نام">Name</label>
                    <input type="text" id="customer-name" class="ledger-input" required>
                </div>
                <div class="form-group">
                    <label for="customer-phone" data-en="Phone (Optional)" data-ur="فون (اختیاری)">Phone (Optional)</label>
                    <input type="tel" id="customer-phone" class="ledger-input">
                </div>
                <div class="form-group">
                    <label for="customer-address" data-en="Address (Optional)" data-ur="پتہ (اختیاری)">Address (Optional)</label>
                    <textarea id="customer-address" class="ledger-textarea"></textarea>
                </div>
                 <div class="form-group">
                    <label for="customer-notes" data-en="Notes (Optional)" data-ur="نوٹس (اختیاری)">Notes (Optional)</label>
                    <textarea id="customer-notes" class="ledger-textarea"></textarea>
                </div>
                <button type="submit" class="btn btn-primary" data-en="Save Customer" data-ur="صارف محفوظ کریں">Save Customer</button>
                <button type="button" class="btn btn-secondary" onclick="closeModal('customer-form-modal')" data-en="Cancel" data-ur="منسوخ کریں">Cancel</button>
            </form>
        </div>
    </div>

    <div id="transaction-form-modal" class="modal">
        <div class="modal-content">
            <span class="modal-close" onclick="closeModal('transaction-form-modal')">&times;</span>
            <h3 data-en="Add Transaction for" data-ur="کے لیے لین دین شامل کریں">Add Transaction for <span id="transaction-modal-customer-name"></span></h3>
            <form id="transaction-form">
                <input type="hidden" id="transaction-customer-id"> <div class="form-group">
                    <label for="transaction-date" data-en="Date" data-ur="تاریخ">Date</label>
                    <input type="date" id="transaction-date" class="ledger-input" required>
                </div>
                <div class="form-group">
                    <label for="transaction-type" data-en="Transaction Type" data-ur="لین دین کی قسم">Transaction Type</label>
                    <select id="transaction-type" class="ledger-select" required>
                        <option value="udhaar" data-en="Udhaar (You Gave / Lena Hai)" data-ur="ادھار (آپ نے دیا / لینا ہے)">Udhaar (You Gave / Lena Hai)</option>
                        <option value="payment" data-en="Payment (You Received / Jama)" data-ur="وصولی (آپ نے وصول کیا / جمع)">Payment (You Received / Jama)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="transaction-amount" data-en="Amount (Rs)" data-ur="رقم (روپے)">Amount (Rs)</label>
                    <input type="number" id="transaction-amount" class="ledger-input" step="0.01" min="0.01" required> </div>
                <div class="form-group">
                    <label for="transaction-method" data-en="Payment Method (Optional)" data-ur="ادائیگی کا طریقہ (اختیاری)">Payment Method (Optional)</label>
                    <select id="transaction-method" class="ledger-select">
                        <option value="" data-en="Select Method" data-ur="طریقہ منتخب کریں">Select Method</option>
                        <option value="Cash" data-en="Cash" data-ur="نقد">Cash</option>
                        <option value="JazzCash" data-en="JazzCash" data-ur="جاز کیش">JazzCash</option>
                        <option value="EasyPaisa" data-en="EasyPaisa" data-ur="ایزی پیسہ">EasyPaisa</option>
                        <option value="Bank Transfer" data-en="Bank Transfer" data-ur="بینک ٹرانسفر">Bank Transfer</option>
                        <option value="Other" data-en="Other" data-ur="دیگر">Other</option>
                    </select>
                </div>
                 <div class="form-group">
                    <label for="transaction-description" data-en="Description (Optional)" data-ur="تفصیل (اختیاری)">Description (Optional)</label>
                    <textarea id="transaction-description" class="ledger-textarea"></textarea>
                </div>
                <button type="submit" class="btn btn-primary" data-en="Save Transaction" data-ur="لین دین محفوظ کریں">Save Transaction</button>
                <button type="button" class="btn btn-secondary" onclick="closeModal('transaction-form-modal')" data-en="Cancel" data-ur="منسوخ کریں">Cancel</button>
            </form>
        </div>
    </div>

     <div id="reminder-modal" class="modal">
        <div class="modal-content">
            <span class="modal-close" onclick="closeModal('reminder-modal')">&times;</span>
            <h3 data-en="Send Payment Reminder" data-ur="ادائیگی کی یاد دہانی بھیجیں">Send Payment Reminder</h3>
            <p id="reminder-text" style="margin-bottom: 15px; white-space: pre-wrap; word-wrap: break-word;"></p>
            <a id="whatsapp-link" href="#" target="_blank" class="btn btn-success" data-en="Send via WhatsApp" data-ur="واٹس ایپ پر بھیجیں">Send via WhatsApp</a>
            <a id="sms-link" href="#" class="btn btn-primary" data-en="Send via SMS" data-ur="ایس ایم ایس پر بھیجیں">Send via SMS</a>
            <button type="button" class="btn btn-secondary" onclick="closeModal('reminder-modal')" data-en="Close" data-ur="بند کریں">Close</button>
        </div>
    </div>

    <div id="alert-modal" class="modal">
        <div class="modal-content">
             <span class="modal-close" onclick="closeModal('alert-modal')">&times;</span>
             <h4 id="alert-title">Alert</h4>
             <p id="alert-message" style="margin: 15px 0;"></p>
             <div id="alert-buttons" style="text-align: right;">
                 <button id="alert-ok-btn" class="btn btn-primary" onclick="closeModal('alert-modal')">OK</button>
                 <button id="alert-confirm-btn" class="btn btn-danger" style="display: none;">Confirm</button>
                 <button id="alert-cancel-btn" class="btn btn-secondary" style="display: none;" onclick="closeModal('alert-modal')">Cancel</button>
             </div>
        </div>
    </div>


    <script>
        // --- Constants and Globals ---
        const DB_NAME = 'DigitalKhataDB';
        const DB_VERSION = 1; // Increment this if schema changes
        const CUSTOMERS_STORE_NAME = 'customers';
        const TRANSACTIONS_STORE_NAME = 'transactions';
        let db; // Holds the database connection
        let currentCustomerId = null; // Track the customer being viewed in details
        let currentLanguage = localStorage.getItem('khataLanguage') || 'en'; // Default to English, load saved preference

        // --- IndexedDB Initialization and Helpers ---
        /**
         * Initializes the IndexedDB database.
         * Creates object stores if they don't exist during upgrade.
         * @returns {Promise<IDBDatabase>} A promise that resolves with the database object or rejects on error.
         */
        function initDB() {
            return new Promise((resolve, reject) => {
                // Request to open the database
                const request = indexedDB.open(DB_NAME, DB_VERSION);

                // Error handler for opening the database
                request.onerror = (event) => {
                    console.error("Database error:", event.target.errorCode);
                    // Use custom alert for user feedback
                    customAlert(getLang("Error opening database. Please ensure IndexedDB is enabled and not in private browsing."), getLang("Database Error"));
                    reject("Error opening database");
                };

                // Success handler for opening the database
                request.onsuccess = (event) => {
                    db = event.target.result; // Store the database connection globally
                    console.log("Database opened successfully");

                    // Error handler for database-level errors after opening
                    db.onerror = (event) => {
                        console.error("Database error (post-open):", event.target.error);
                        customAlert(`Database error: ${event.target.error}`, "Database Error");
                    };

                    resolve(db);
                };

                // Upgrade handler (runs only when DB_VERSION increases or DB is first created)
                request.onupgradeneeded = (event) => {
                    db = event.target.result;
                    console.log("Upgrading database...");

                    // Create Customers Object Store if it doesn't exist
                    if (!db.objectStoreNames.contains(CUSTOMERS_STORE_NAME)) {
                        // Create store with 'id' as key path and auto-incrementing keys
                        const customerStore = db.createObjectStore(CUSTOMERS_STORE_NAME, { keyPath: 'id', autoIncrement: true });
                        // Create indexes for efficient searching/sorting
                        customerStore.createIndex('name', 'name', { unique: false }); // Index on customer name
                        customerStore.createIndex('phone', 'phone', { unique: false }); // Index on phone (optional, might not be unique)
                        console.log("Customers store created");
                    }

                    // Create Transactions Object Store if it doesn't exist
                    if (!db.objectStoreNames.contains(TRANSACTIONS_STORE_NAME)) {
                        // Create store with 'id' as key path and auto-incrementing keys
                        const transactionStore = db.createObjectStore(TRANSACTIONS_STORE_NAME, { keyPath: 'id', autoIncrement: true });
                        // Create indexes for efficient searching/sorting
                        transactionStore.createIndex('customerId', 'customerId', { unique: false }); // Index on customer ID (foreign key)
                        transactionStore.createIndex('date', 'date', { unique: false }); // Index on transaction date
                        transactionStore.createIndex('customerId_date', ['customerId', 'date'], { unique: false }); // Compound index for filtering by customer and date
                        console.log("Transactions store created");
                    }
                    console.log("Database upgrade complete");
                };
            });
        }

        // --- Generic DB Operations (CRUD) ---

        /**
         * Adds an object to a specified object store.
         * @param {string} storeName - The name of the object store.
         * @param {object} object - The object to add.
         * @returns {Promise<number>} A promise that resolves with the new object's ID or rejects on error.
         */
        function addObject(storeName, object) {
            return new Promise((resolve, reject) => {
                if (!db) return reject("DB not initialized");
                // Start a read-write transaction
                const transaction = db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                // Request to add the object
                const request = store.add(object);

                request.onsuccess = (event) => resolve(event.target.result); // Return the new ID
                request.onerror = (event) => {
                    console.error(`Error adding to ${storeName}:`, event.target.error);
                    reject(event.target.error);
                };
                // Optional: Handle transaction errors
                transaction.onerror = (event) => {
                     console.error(`Transaction error adding to ${storeName}:`, event.target.error);
                     reject(event.target.error);
                };
            });
        }

        /**
         * Retrieves an object from a specified store by its key.
         * @param {string} storeName - The name of the object store.
         * @param {number | string} key - The key of the object to retrieve.
         * @returns {Promise<object|undefined>} A promise that resolves with the object or undefined if not found, or rejects on error.
         */
        function getObject(storeName, key) {
            return new Promise((resolve, reject) => {
                if (!db) return reject("DB not initialized");
                // Start a read-only transaction
                const transaction = db.transaction([storeName], 'readonly');
                const store = transaction.objectStore(storeName);
                // Request to get the object by key
                const request = store.get(key);

                request.onsuccess = (event) => resolve(event.target.result); // Returns the object or undefined
                request.onerror = (event) => {
                     console.error(`Error getting from ${storeName}:`, event.target.error);
                     reject(event.target.error);
                };
                 transaction.onerror = (event) => {
                     console.error(`Transaction error getting from ${storeName}:`, event.target.error);
                     reject(event.target.error);
                };
            });
        }

        /**
         * Updates an existing object or adds it if it doesn't exist in a specified store.
         * @param {string} storeName - The name of the object store.
         * @param {object} object - The object to add or update (must have a valid key property).
         * @returns {Promise<number>} A promise that resolves with the object's key or rejects on error.
         */
        function updateObject(storeName, object) {
            return new Promise((resolve, reject) => {
                if (!db) return reject("DB not initialized");
                // Start a read-write transaction
                const transaction = db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                // Request to put (add or update) the object
                const request = store.put(object);

                request.onsuccess = (event) => resolve(event.target.result); // Returns the key
                request.onerror = (event) => {
                     console.error(`Error updating ${storeName}:`, event.target.error);
                     reject(event.target.error);
                };
                 transaction.onerror = (event) => {
                     console.error(`Transaction error updating ${storeName}:`, event.target.error);
                     reject(event.target.error);
                };
            });
        }

        /**
         * Deletes an object from a specified store by its key.
         * @param {string} storeName - The name of the object store.
         * @param {number | string} key - The key of the object to delete.
         * @returns {Promise<void>} A promise that resolves on successful deletion or rejects on error.
         */
        function deleteObject(storeName, key) {
            return new Promise((resolve, reject) => {
                if (!db) return reject("DB not initialized");
                 // Start a read-write transaction
                const transaction = db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                // Request to delete the object by key
                const request = store.delete(key);

                request.onsuccess = (event) => resolve(); // No return value on success
                request.onerror = (event) => {
                    console.error(`Error deleting from ${storeName}:`, event.target.error);
                    reject(event.target.error);
                };
                 transaction.onerror = (event) => {
                     console.error(`Transaction error deleting from ${storeName}:`, event.target.error);
                     reject(event.target.error);
                };
            });
        }

        /**
         * Retrieves all objects from a store, optionally filtering by index and query.
         * @param {string} storeName - The name of the object store.
         * @param {string | null} [indexName=null] - Optional index name to query.
         * @param {IDBValidKey | IDBKeyRange | null} [query=null] - Optional query (key or range) for the index.
         * @returns {Promise<Array<object>>} A promise that resolves with an array of objects or rejects on error.
         */
        function getAllObjects(storeName, indexName = null, query = null) {
             return new Promise((resolve, reject) => {
                if (!db) return reject("DB not initialized");
                // Start a read-only transaction
                const transaction = db.transaction([storeName], 'readonly');
                const store = transaction.objectStore(storeName);
                let request;

                // Determine whether to use an index or get all from the store
                if (indexName && query !== null) {
                    const index = store.index(indexName);
                    request = index.getAll(query); // Get all matching the index query
                } else {
                    request = store.getAll(); // Get all objects in the store
                }

                request.onsuccess = (event) => resolve(event.target.result); // Returns an array of objects
                request.onerror = (event) => {
                    console.error(`Error getting all from ${storeName}:`, event.target.error);
                    reject(event.target.error);
                };
                 transaction.onerror = (event) => {
                     console.error(`Transaction error getting all from ${storeName}:`, event.target.error);
                     reject(event.target.error);
                };
            });
        }

        // --- Customer Specific Operations ---

        /**
         * Adds a new customer to the database. Initializes balance to 0.
         * @param {object} customerData - Object containing customer details (name, phone, address, notes).
         * @returns {Promise<number>} A promise that resolves with the new customer's ID.
         */
        async function addCustomer(customerData) {
            // Create a copy to avoid modifying the original object if needed elsewhere
            const customerToAdd = { ...customerData };
            // Ensure 'id' is not present for auto-increment to work correctly
            delete customerToAdd.id;
            // Initialize balance for new customers
            customerToAdd.balance = 0;

            try {
                 // Add customer object to the store
                 const id = await addObject(CUSTOMERS_STORE_NAME, customerToAdd);
                 // Refresh the UI after adding
                 await loadCustomers();
                 await updateDashboard();
                 return id; // Return the newly generated ID
            } catch (error) {
                 // Log and re-throw the error to be handled by the form submit handler
                 console.error("Error in addCustomer -> addObject:", error);
                 throw error;
            }
        }

        /**
         * Updates an existing customer's data. Preserves balance if not provided.
         * @param {object} customerData - Object containing customer details, including the 'id'.
         * @returns {Promise<void>}
         */
        async function updateCustomer(customerData) {
            // Fetch existing customer to preserve balance if it's not included in update data
            const existingCustomer = await getObject(CUSTOMERS_STORE_NAME, customerData.id);
            if (existingCustomer && !('balance' in customerData)) {
                customerData.balance = existingCustomer.balance; // Preserve existing balance
            }
            // Update the customer object in the store
            await updateObject(CUSTOMERS_STORE_NAME, customerData);
            // Refresh the UI
            await loadCustomers();
            // If the updated customer is currently being viewed, refresh the details view
            if (currentCustomerId === customerData.id) {
                 await loadCustomerDetails(customerData.id);
            }
            await updateDashboard();
        }

        /**
         * Deletes a customer and all their associated transactions.
         * @param {number} customerId - The ID of the customer to delete.
         * @returns {Promise<void>}
         */
        async function deleteCustomer(customerId) {
            // 1. Delete all transactions associated with this customer
            const transactions = await getTransactionsForCustomer(customerId);
            // Create an array of promises for deleting each transaction
            const deletePromises = transactions.map(tx => deleteObject(TRANSACTIONS_STORE_NAME, tx.id));
            // Wait for all transaction deletions to complete
            await Promise.all(deletePromises);
            console.log(`Deleted ${transactions.length} transactions for customer ID ${customerId}`);

            // 2. Delete the customer record itself
            await deleteObject(CUSTOMERS_STORE_NAME, customerId);
            console.log(`Deleted customer ID ${customerId}`);

            // 3. Refresh the UI
            await loadCustomers();
            await updateDashboard();
            // If the deleted customer was being viewed, switch back to the list view
            if (currentCustomerId === customerId) {
                showCustomerListView();
            }
            customAlert(getLang("Customer and all related transactions deleted."), getLang("Deleted"));
        }

        /**
         * Retrieves a single customer by their ID.
         * @param {number} customerId - The ID of the customer.
         * @returns {Promise<object|undefined>} The customer object or undefined if not found.
         */
        async function getCustomer(customerId) {
            return await getObject(CUSTOMERS_STORE_NAME, customerId);
        }

        /**
         * Retrieves all customers from the database.
         * @returns {Promise<Array<object>>} An array of all customer objects.
         */
        async function getAllCustomers() {
            return await getAllObjects(CUSTOMERS_STORE_NAME);
        }

        // --- Transaction Specific Operations ---

        /**
         * Adds a new transaction and updates the customer's balance.
         * Calculates the running balance *after* this transaction.
         * @param {object} transactionData - Object containing transaction details (customerId, date, type, amount, etc.).
         * @returns {Promise<number>} A promise resolving with the new transaction's ID.
         */
        async function addTransaction(transactionData) {
            const customerId = transactionData.customerId;
            const customer = await getCustomer(customerId);
            if (!customer) throw new Error("Customer not found for transaction");

            // --- Calculate running balance for this specific transaction ---
            // Get all transactions for this customer *before* or on the *same date* as the new one.
            // Sorting by ID will be needed later if multiple tx on the same day.
            const transactionsOnOrBefore = await getTransactionsForCustomer(
                customerId,
                null, // No start date filter
                transactionData.date // Filter up to and including the new transaction's date
            );

            // Sort chronologically, and by ID for same-day transactions to ensure order
            transactionsOnOrBefore.sort((a, b) => {
                const dateA = new Date(a.date).getTime();
                const dateB = new Date(b.date).getTime();
                if (dateA !== dateB) {
                    return dateA - dateB;
                }
                // If dates are the same, ensure existing transactions come before potential new one (if IDs exist)
                return (a.id || Infinity) - (b.id || Infinity);
            });

            // Calculate the balance *before* this new transaction
            let balanceBefore = 0;
            transactionsOnOrBefore.forEach(tx => {
                 // Ensure we don't double-count if editing/re-adding a transaction (though this function is add-only)
                 // This calculation correctly sums up the balance *before* the new transaction is added.
                 balanceBefore += (tx.type === 'udhaar' ? parseFloat(tx.amount) : -parseFloat(tx.amount));
            });

            // Calculate the balance *after* this new transaction
            const amount = parseFloat(transactionData.amount);
            transactionData.balanceAfter = balanceBefore + (transactionData.type === 'udhaar' ? amount : -amount);
            // --- End running balance calculation ---

            // Add the new transaction object to the database
            const txId = await addObject(TRANSACTIONS_STORE_NAME, transactionData);

            // Update the customer's overall balance stored in the customer object
            await updateCustomerBalance(customerId);

            // Refresh UI if the affected customer is currently being viewed
            if (currentCustomerId === customerId) {
                await loadCustomerDetails(customerId); // Reloads details and transactions table
            }
            await updateDashboard(); // Update dashboard totals
            return txId;
        }

        /**
         * Recalculates and updates a customer's total balance based on all their transactions.
         * Saves the updated balance to the customer object in the database.
         * @param {number} customerId - The ID of the customer whose balance needs updating.
         * @returns {Promise<number>} The newly calculated total balance.
         */
        async function updateCustomerBalance(customerId) {
             const customer = await getCustomer(customerId);
             if (!customer) {
                 console.error(`Cannot update balance: Customer ID ${customerId} not found.`);
                 return NaN; // Indicate failure
             }

             // Get all transactions for this customer
             const transactions = await getTransactionsForCustomer(customerId);
             let totalBalance = 0;
             // Sum up amounts based on transaction type
             transactions.forEach(tx => {
                 const amount = parseFloat(tx.amount);
                 if (!isNaN(amount)) { // Only process valid amounts
                    totalBalance += (tx.type === 'udhaar' ? amount : -amount);
                 } else {
                    console.warn(`Invalid amount found in transaction ID ${tx.id} for customer ${customerId}`);
                 }
             });

             // Update the balance property on the customer object
             customer.balance = totalBalance;
             // Save the updated customer object back to the database
             await updateObject(CUSTOMERS_STORE_NAME, customer);
             // Update dashboard totals reflecting the change
             await updateDashboard();
             return totalBalance; // Return the calculated balance
        }


        /**
         * Retrieves transactions for a specific customer, optionally filtering by date range and search term.
         * Calculates and adds the running balance (`balanceAfter`) to each transaction object in the result.
         * @param {number} customerId - The ID of the customer.
         * @param {string | null} [startDate=null] - Start date filter (YYYY-MM-DD).
         * @param {string | null} [endDate=null] - End date filter (YYYY-MM-DD).
         * @param {string | null} [searchTerm=null] - Search term for description or payment method.
         * @returns {Promise<Array<object>>} A promise resolving with an array of transaction objects, sorted chronologically.
         */
        async function getTransactionsForCustomer(customerId, startDate = null, endDate = null, searchTerm = null) {
            if (!db) return []; // Return empty array if DB not ready

            return new Promise(async (resolve, reject) => {
                const transaction = db.transaction([TRANSACTIONS_STORE_NAME], 'readonly');
                const store = transaction.objectStore(TRANSACTIONS_STORE_NAME);
                // Use the 'customerId' index to efficiently get transactions for only this customer
                const index = store.index('customerId');

                let results = [];
                // Open a cursor on the index for the specific customerId
                const request = index.openCursor(IDBKeyRange.only(customerId));

                request.onsuccess = (event) => {
                    const cursor = event.target.result;
                    if (cursor) {
                        // A transaction for this customer was found
                        const tx = cursor.value;
                        let dateMatch = true;
                        let searchMatch = true;

                        // Apply Date Filtering (if dates provided)
                        const txDate = new Date(tx.date + 'T00:00:00'); // Ensure date is parsed correctly, treat as local time start of day

                        if (startDate) {
                            const filterStartDate = new Date(startDate + 'T00:00:00');
                            if (txDate < filterStartDate) {
                                dateMatch = false;
                            }
                        }
                        if (endDate) {
                            // Adjust end date filter to be inclusive (end of the day)
                            const filterEndDate = new Date(endDate + 'T23:59:59');
                            if (txDate > filterEndDate) {
                                dateMatch = false;
                            }
                        }

                        // Apply Search Term Filtering (case-insensitive)
                        if (searchTerm) {
                           const term = searchTerm.toLowerCase();
                           const description = (tx.description || '').toLowerCase();
                           const method = (tx.paymentMethod || '').toLowerCase();
                           // Search in description OR payment method
                           searchMatch = description.includes(term) || method.includes(term);
                        }

                        // Add transaction to results if it matches all filters
                        if (dateMatch && searchMatch) {
                            results.push(tx);
                        }
                        cursor.continue(); // Move to the next transaction for this customer
                    } else {
                        // No more transactions for this customer (cursor is null)

                        // Sort all collected results chronologically (by date, then by ID for same-day)
                        results.sort((a, b) => {
                             const dateA = new Date(a.date).getTime();
                             const dateB = new Date(b.date).getTime();
                             if (dateA !== dateB) {
                                 return dateA - dateB;
                             }
                             return (a.id || 0) - (b.id || 0); // Sort by ID if dates are identical
                         });


                        // Calculate running balance *after* filtering and sorting
                        let runningBalance = 0;
                         results.forEach(tx => {
                             const amount = parseFloat(tx.amount);
                             if(!isNaN(amount)) {
                                runningBalance += (tx.type === 'udhaar' ? amount : -amount);
                                tx.balanceAfter = runningBalance; // Add running balance property to each transaction object
                             } else {
                                 tx.balanceAfter = runningBalance; // Keep running balance if amount is invalid
                                 console.warn(`Invalid amount in transaction ID ${tx.id} during running balance calculation.`);
                             }
                         });

                        resolve(results); // Resolve the promise with the filtered, sorted, and processed transactions
                    }
                };
                request.onerror = (event) => {
                    console.error("Error fetching transactions:", event.target.error);
                    reject(event.target.error);
                };
                 transaction.onerror = (event) => {
                     console.error(`Transaction error fetching transactions:`, event.target.error);
                     reject(event.target.error);
                };
            });
        }

        // --- UI Rendering Functions ---

        /**
         * Formats a number as Pakistani Rupees (Rs).
         * Handles NaN and invalid inputs gracefully.
         * @param {number | string} amount - The amount to format.
         * @returns {string} The formatted currency string (e.g., "Rs 123.45").
         */
        function formatCurrency(amount) {
            const num = parseFloat(amount);
            // Return a default or error indicator if the amount is not a valid number
            if (isNaN(num)) {
                return `Rs ---`; // Indicate invalid data
            }
            // Format to 2 decimal places
            return `Rs ${num.toFixed(2)}`;
        }

        /**
         * Formats a date string (YYYY-MM-DD) into a more readable format (e.g., "Apr 16, 2025").
         * Uses Pakistani locale/timezone if possible, otherwise falls back.
         * @param {string} dateString - The date string in YYYY-MM-DD format.
         * @returns {string} The formatted date string or 'Invalid Date'.
         */
        function formatDate(dateString) {
            if (!dateString) return ''; // Return empty if no date string provided
            // Parse the date string. Adding T00:00:00 helps ensure it's parsed as local date start.
             const date = new Date(dateString + 'T00:00:00');
             // Check if the resulting date object is valid
             if (isNaN(date.getTime())) {
                 console.warn(`Invalid date string encountered: ${dateString}`);
                 return 'Invalid Date';
             }

            // Define formatting options
            const options = { year: 'numeric', month: 'short', day: 'numeric' };
            try {
                // Attempt to use a locale that commonly uses the desired format and timezone
                // 'en-PK' (English - Pakistan) or 'sd-PK' (Sindhi - Pakistan) might work
                options.timeZone = 'Asia/Karachi'; // Specify Pakistan Standard Time
                return date.toLocaleDateString('en-PK', options);
            } catch (e) {
                // Fallback if locale or timezone formatting fails
                console.warn("Timezone/Locale formatting failed, using default locale.", e);
                 // Use browser's default locale without timezone specification
                 return date.toLocaleDateString(undefined, options);
            }
        }

        /**
         * Renders a balance amount with appropriate styling (positive/negative/zero) and labels.
         * @param {number | string} balance - The balance amount.
         * @returns {string} HTML string representing the styled balance.
         */
        function renderBalance(balance) {
            const amount = parseFloat(balance);
             // Handle cases where balance is not a valid number
             if (isNaN(amount)) {
                 console.warn(`Invalid balance value encountered: ${balance}`);
                 return `<span>Rs --- (${getLang('Error')})</span>`; // Indicate error
             }
            const formatted = formatCurrency(Math.abs(amount)); // Format the absolute value
            // Use a small tolerance for floating-point comparisons near zero
            if (amount > 0.005) { // Positive balance (Lena Hai)
                return `<span class="balance-positive">${formatted} (${getLang('Lena Hai')})</span>`;
            } else if (amount < -0.005) { // Negative balance (Dena Hai)
                return `<span class="balance-negative">${formatted} (${getLang('Dena Hai')})</span>`;
            } else { // Zero balance (Settled)
                return `<span>${formatCurrency(0)} (${getLang('Settled')})</span>`;
            }
        }

        /**
         * Loads customers from the database and renders them in the customer table.
         * Optionally filters customers based on a search term.
         * @param {string} [searchTerm=''] - Optional search term to filter customers by name or phone.
         */
        async function loadCustomers(searchTerm = '') {
            try {
                const customers = await getAllCustomers();
                const tableBody = document.getElementById('customer-table-body');
                tableBody.innerHTML = ''; // Clear existing rows before rendering

                const lowerCaseSearchTerm = searchTerm.toLowerCase();

                // Filter customers based on search term (name or phone)
                const filteredCustomers = customers.filter(c => {
                    // Check name (case-insensitive), handle potential null/undefined names
                    const nameMatch = c.name ? c.name.toLowerCase().includes(lowerCaseSearchTerm) : false;
                    // Check phone (exact or partial match), handle potential null/undefined phones
                    const phoneMatch = c.phone ? c.phone.includes(searchTerm) : false; // No toLowerCase for phone usually
                    return nameMatch || phoneMatch;
                });

                // Display message if no customers match the filter or if there are no customers
                if (filteredCustomers.length === 0) {
                    const colspan = 4; // Number of columns in the customer table
                    tableBody.innerHTML = `<tr><td colspan="${colspan}" style="text-align:center;">${getLang(searchTerm ? 'No customers match your search.' : 'No customers found.')}</td></tr>`;
                    return; // Exit the function early
                }

                // Sort the filtered customers alphabetically by name
                filteredCustomers.sort((a, b) => (a.name || '').localeCompare(b.name || ''));

                // Render each customer row
                filteredCustomers.forEach(customer => {
                    const row = tableBody.insertRow();
                    // Provide default values if name or phone are missing
                    const displayName = customer.name || 'Unnamed Customer';
                    const displayPhone = customer.phone || '-';

                    // Use innerHTML for easier structure, ensure data is properly handled (though basic here)
                    row.innerHTML = `
                        <td><a href="#" onclick="event.preventDefault(); showCustomerDetailsView(${customer.id});">${displayName}</a></td>
                        <td class="hide-mobile">${displayPhone}</td>
                        <td>${renderBalance(customer.balance)}</td>
                        <td class="no-print">
                            <button class="btn btn-warning btn-icon" onclick="editCustomer(${customer.id})" title="${getLang('Edit')}">✏️</button>
                            <button class="btn btn-danger btn-icon" onclick="confirmDeleteCustomer(${customer.id})" title="${getLang('Delete')}">🗑️</button>
                        </td>
                    `;
                    // Apply Urdu font if needed (handled globally now)
                    // wrapUrduTextNodes(row);
                });
            } catch (error) {
                console.error("Error loading customers:", error);
                customAlert(`${getLang("Error loading customers:")} ${error.message}`, getLang("Error"));
                // Optionally display an error message in the table body
                document.getElementById('customer-table-body').innerHTML = `<tr><td colspan="4" style="text-align:center; color: red;">${getLang("Error loading customers.")}</td></tr>`;
            }
        }


        /**
         * Loads details and transactions for a specific customer into the details view.
         * @param {number} customerId - The ID of the customer to load.
         */
        async function loadCustomerDetails(customerId) {
            try {
                currentCustomerId = customerId; // Set the globally tracked customer ID
                const customer = await getCustomer(customerId);

                // Handle case where customer might not be found (e.g., deleted in another tab)
                if (!customer) {
                    customAlert(getLang("Customer not found."), getLang("Error"));
                    showCustomerListView(); // Go back to the list if customer doesn't exist
                    return;
                }

                // --- Populate Customer Info Section ---
                const displayName = customer.name || 'Unnamed Customer'; // Default for missing name
                document.getElementById('details-customer-name').textContent = displayName; // Set header title

                // Populate the customer info div
                document.getElementById('customer-info').innerHTML = `
                    <p><strong>${getLang('Phone')}:</strong> ${customer.phone || '-'}</p>
                    <p><strong>${getLang('Address')}:</strong> ${customer.address || '-'}</p>
                    <p><strong>${getLang('Notes')}:</strong> ${customer.notes || '-'}</p>
                    <p><strong>${getLang('Current Balance')}:</strong> <span id="details-current-balance-header">${renderBalance(customer.balance)}</span></p>
                `;

                // --- Reset Filters and Load Transactions ---
                // Clear any previous filter values when loading a new customer
                document.getElementById('filter-start-date').value = '';
                document.getElementById('filter-end-date').value = '';
                document.getElementById('transaction-search').value = '';

                // Load and display transactions for this customer (without filters initially)
                await loadTransactions(customerId);

                // Apply Urdu font if needed (handled globally now)
                // wrapUrduTextNodes(document.getElementById('customer-details-view'));

            } catch (error) {
                console.error(`Error loading details for customer ${customerId}:`, error);
                customAlert(`${getLang("Error loading customer details:")} ${error.message}`, getLang("Error"));
                showCustomerListView(); // Attempt to go back to list view on error
            }
        }


        /**
         * Loads and renders transactions for the currently viewed customer, applying filters.
         * Updates the balance summary display.
         * @param {number} customerId - The ID of the customer whose transactions to load.
         * @param {string | null} [startDate=null] - Optional start date filter.
         * @param {string | null} [endDate=null] - Optional end date filter.
         * @param {string | null} [searchTerm=null] - Optional search term filter.
         */
        async function loadTransactions(customerId, startDate = null, endDate = null, searchTerm = null) {
            try {
                // Fetch transactions using the helper function which includes filtering and balance calculation
                const transactions = await getTransactionsForCustomer(customerId, startDate, endDate, searchTerm);
                const tableBody = document.getElementById('transaction-table-body');
                tableBody.innerHTML = ''; // Clear existing transaction rows

                // Fetch the customer again to get the most up-to-date *overall* balance for the summary display
                // This ensures the summary reflects the total, even if filters are applied to the table.
                const customer = await getCustomer(customerId);
                const currentTotalBalance = customer ? customer.balance : 0;

                // Display message if no transactions match the criteria
                if (transactions.length === 0) {
                     const colspan = 5; // Number of columns in the transaction table
                     tableBody.innerHTML = `<tr><td colspan="${colspan}" style="text-align:center;">${getLang('No transactions found for the selected criteria.')}</td></tr>`;
                } else {
                    // Render each transaction row (transactions are already sorted and have balanceAfter)
                    transactions.forEach(tx => {
                        const row = tableBody.insertRow();
                        // Use innerHTML for structure, ensure data is formatted
                        row.innerHTML = `
                            <td>${formatDate(tx.date)}</td>
                            <td style="color: ${tx.type === 'udhaar' ? 'var(--danger-color)' : 'var(--success-color)'}; font-weight: 500;">
                                ${tx.type === 'udhaar' ? getLang('Udhaar') : getLang('Payment')}
                                ${tx.paymentMethod ? ` <span style="font-size: 0.9em; color: #555;">(${getLang(tx.paymentMethod) || tx.paymentMethod})</span>` : ''}
                            </td>
                            <td class="hide-mobile">${tx.description || '-'}</td>
                            <td>${formatCurrency(tx.amount)}</td>
                            <td>${renderBalance(tx.balanceAfter)}</td>
                            `;
                         // Apply Urdu font if needed (handled globally now)
                         // wrapUrduTextNodes(row);
                    });
                }

                // Update the summary balance display (at the bottom of the table) using the customer's current total balance
                document.getElementById('details-current-balance').innerHTML = renderBalance(currentTotalBalance);
                // Also update the balance shown in the customer info header (redundant but ensures consistency)
                document.getElementById('details-current-balance-header').innerHTML = renderBalance(currentTotalBalance);

            } catch (error) {
                 console.error(`Error loading transactions for customer ${customerId}:`, error);
                 customAlert(`${getLang("Error loading transactions:")} ${error.message}`, getLang("Error"));
                 // Optionally display an error message in the table body
                 document.getElementById('transaction-table-body').innerHTML = `<tr><td colspan="5" style="text-align:center; color: red;">${getLang("Error loading transactions.")}</td></tr>`;
            }
        }

        /**
         * Updates the dashboard summary cards (Total Customers, Total Lena Hai, Total Dena Hai).
         */
        async function updateDashboard() {
            try {
                const customers = await getAllCustomers();
                const totalCustomers = customers.length;
                let totalPositiveBalance = 0; // Sum of all positive balances (Lena Hai)
                let totalNegativeBalance = 0; // Sum of all negative balances (Dena Hai - stored as negative)

                customers.forEach(c => {
                     // Ensure balance is a valid number before processing
                     const balance = parseFloat(c.balance);
                     if (!isNaN(balance)) {
                         if (balance > 0.005) { // Use tolerance for positive balance
                             totalPositiveBalance += balance;
                         } else if (balance < -0.005) { // Use tolerance for negative balance
                             totalNegativeBalance += balance; // Keep it negative for summation
                         }
                     } else {
                         // Log a warning if a customer has an invalid balance
                         console.warn(`Customer ID ${c.id} ('${c.name}') has invalid balance: ${c.balance}`);
                     }
                });

                // Update the text content of the dashboard elements
                document.getElementById('total-customers').textContent = totalCustomers;
                // Format positive balance (Lena Hai)
                document.getElementById('total-balance-positive').textContent = formatCurrency(totalPositiveBalance);
                // Format negative balance (Dena Hai), display its absolute value
                document.getElementById('total-balance-negative').textContent = formatCurrency(Math.abs(totalNegativeBalance));

                // Apply Urdu font if needed (handled globally now)
                // wrapUrduTextNodes(document.querySelector('.dashboard-summary'));

            } catch (error) {
                console.error("Error updating dashboard:", error);
                customAlert(`${getLang("Error updating dashboard:")} ${error.message}`, getLang("Error"));
            }
        }


        // --- UI Navigation ---

        /**
         * Shows the main customer list view and hides the details view.
         * Resets the current customer ID and refreshes the customer list and dashboard.
         */
        function showCustomerListView() {
            document.getElementById('customer-list-view').style.display = 'block';
            document.getElementById('customer-details-view').style.display = 'none';
            document.getElementById('printable-report-content').style.display = 'none'; // Ensure report area is hidden
            currentCustomerId = null; // Reset the currently viewed customer ID
            loadCustomers(); // Refresh the customer list
            updateDashboard(); // Refresh the dashboard summary
            // Clear search input when going back to list
            document.getElementById('customer-search').value = '';
        }

        /**
         * Loads customer details and shows the customer details view, hiding the list view.
         * @param {number} customerId - The ID of the customer to display.
         */
        async function showCustomerDetailsView(customerId) {
            await loadCustomerDetails(customerId); // Load data *before* switching view
            // Ensure data loading was successful before switching
            if (currentCustomerId === customerId) { // Check if loadCustomerDetails succeeded in setting the ID
                document.getElementById('customer-list-view').style.display = 'none';
                document.getElementById('customer-details-view').style.display = 'block';
                document.getElementById('printable-report-content').style.display = 'none'; // Ensure report area is hidden
            } else {
                // If loadCustomerDetails failed (e.g., customer not found), stay on the list view
                console.warn("Failed to load customer details, staying on list view.");
            }
        }

        // --- Modal Handling ---

        /**
         * Opens a modal dialog by its ID.
         * @param {string} modalId - The HTML ID of the modal element.
         */
        function openModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal) {
                modal.style.display = 'block';
                 // Optional: Add a class to body to prevent scrolling while modal is open
                 // document.body.classList.add('modal-open');
            } else {
                console.error(`Modal with ID "${modalId}" not found.`);
            }
        }

        /**
         * Closes a modal dialog by its ID.
         * @param {string} modalId - The HTML ID of the modal element.
         */
        function closeModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal) {
                modal.style.display = 'none';
                 // Optional: Remove the body class
                 // document.body.classList.remove('modal-open');
            } else {
                console.error(`Modal with ID "${modalId}" not found.`);
            }
        }

        // Add event listener to close modals when clicking outside the modal content
        window.addEventListener('click', function(event) {
            const modals = document.querySelectorAll('.modal');
            modals.forEach(modal => {
                // Check if the modal is currently displayed and the click target is the modal backdrop itself
                if (modal.style.display === 'block' && event.target === modal) {
                    // Find the specific ID of the modal that was clicked
                    const modalId = modal.id;
                    if (modalId) {
                       closeModal(modalId);
                    }
                }
            });
        });


        // --- Form Handling ---

        /**
         * Sets up event listeners for the customer and transaction forms.
         */
        function setupForms() {
            // --- Customer Form (Add/Edit) ---
            const customerForm = document.getElementById('customer-form');
            customerForm.addEventListener('submit', async (e) => {
                e.preventDefault(); // Prevent default HTML form submission

                // Gather form data
                const customerData = {
                    // Read ID, parse if exists (for edit), otherwise null (for add)
                    id: document.getElementById('customer-id').value ? parseInt(document.getElementById('customer-id').value, 10) : null,
                    name: document.getElementById('customer-name').value.trim(),
                    phone: document.getElementById('customer-phone').value.trim(),
                    address: document.getElementById('customer-address').value.trim(),
                    notes: document.getElementById('customer-notes').value.trim()
                };

                // Basic validation
                if (!customerData.name) {
                    customAlert(getLang("Customer name is required."), getLang("Validation Error"));
                    return; // Stop submission if validation fails
                }

                // Show loading/saving indicator (optional)
                // customAlert(getLang("Saving..."), getLang("In Progress"));

                try {
                    if (customerData.id) { // If ID exists, it's an update operation
                        await updateCustomer(customerData);
                        customAlert(getLang("Customer updated successfully."), getLang("Success"));
                    } else { // No ID, it's an add operation
                        await addCustomer(customerData); // addCustomer handles removing null ID
                        customAlert(getLang("Customer added successfully."), getLang("Success"));
                    }
                    closeModal('customer-form-modal'); // Close modal on success
                    customerForm.reset(); // Reset form fields
                    document.getElementById('customer-id').value = ''; // Explicitly clear hidden ID field
                } catch (error) {
                    console.error("Error saving customer:", error);
                    // Provide more specific feedback if possible (e.g., constraint errors)
                    let errorMessage = getLang("Error saving customer:");
                     if (error.name === 'ConstraintError') {
                         // This error might occur if a unique index constraint is violated (though none are strictly unique here)
                         errorMessage += ` ${getLang("A potential conflict occurred. Please check the data.")}`;
                     } else if (error.message) {
                         errorMessage += ` ${error.message}`;
                     } else {
                         errorMessage += ` ${getLang("An unknown error occurred.")}`;
                     }
                     customAlert(errorMessage, getLang("Error"));
                     // Close the "Saving..." alert if it was shown
                     // closeModal('alert-modal');
                }
            });

            // --- Transaction Form (Add) ---
            const transactionForm = document.getElementById('transaction-form');
            transactionForm.addEventListener('submit', async (e) => {
                e.preventDefault(); // Prevent default HTML form submission

                // Gather form data
                const transactionData = {
                    // Ensure customerId is parsed as an integer
                    customerId: parseInt(document.getElementById('transaction-customer-id').value, 10),
                    date: document.getElementById('transaction-date').value,
                    type: document.getElementById('transaction-type').value,
                    // Ensure amount is parsed as a float
                    amount: parseFloat(document.getElementById('transaction-amount').value),
                    paymentMethod: document.getElementById('transaction-method').value,
                    description: document.getElementById('transaction-description').value.trim()
                };

                 // --- Input Validation ---
                if (!transactionData.customerId || isNaN(transactionData.customerId)) {
                    customAlert(getLang("Invalid customer ID."), getLang("Validation Error"));
                    return;
                }
                if (!transactionData.date) {
                    customAlert(getLang("Please select a transaction date."), getLang("Validation Error"));
                     return;
                }
                 // Check if amount is a valid positive number
                 if (isNaN(transactionData.amount) || transactionData.amount <= 0) {
                    customAlert(getLang("Please enter a valid positive amount."), getLang("Validation Error"));
                    return;
                }
                // --- End Validation ---

                // Show loading/saving indicator (optional)
                // customAlert(getLang("Saving Transaction..."), getLang("In Progress"));

                try {
                    // Call the function to add the transaction to the database
                    await addTransaction(transactionData);
                    customAlert(getLang("Transaction added successfully."), getLang("Success"));
                    closeModal('transaction-form-modal'); // Close modal on success
                    transactionForm.reset(); // Reset form fields
                    // UI refresh is handled within addTransaction if the current customer is viewed
                } catch (error) {
                    console.error("Error saving transaction:", error);
                     customAlert(`${getLang("Error saving transaction:")} ${error.message || getLang("An unknown error occurred.")}`, getLang("Error"));
                     // Close the "Saving..." alert if it was shown
                     // closeModal('alert-modal');
                }
            });
        }

        // --- Event Listeners Setup ---

        /**
         * Sets up all major event listeners for buttons, inputs, etc.
         */
        function setupEventListeners() {
            // --- Customer List View Buttons ---

            // "Add New Customer" Button
            document.getElementById('add-customer-btn').addEventListener('click', () => {
                document.getElementById('customer-form').reset(); // Clear form fields
                document.getElementById('customer-id').value = ''; // Ensure ID is empty for add mode
                // Set modal title for "Add" mode and apply language
                const titleElement = document.getElementById('customer-modal-title');
                titleElement.dataset.en = 'Add New Customer';
                titleElement.dataset.ur = 'نیا صارف شامل کریں';
                titleElement.textContent = getLang('Add New Customer'); // Set initial text
                setLanguage(currentLanguage); // Re-apply to ensure correct language if switched
                openModal('customer-form-modal'); // Open the modal
            });

            // Customer Search Input (Live Filtering)
             document.getElementById('customer-search').addEventListener('input', (e) => {
                 // Call loadCustomers with the current search term on each input change
                 loadCustomers(e.target.value.trim());
             });

            // --- Customer Details View Buttons ---

            // "Back to List" Button
            document.getElementById('back-to-list-btn').addEventListener('click', showCustomerListView);

            // "Add Transaction" Button (in Details View)
            document.getElementById('add-transaction-btn').addEventListener('click', async () => {
                // Ensure a customer is currently selected
                if (!currentCustomerId) {
                    console.warn("Add transaction clicked but no customer selected.");
                    customAlert(getLang("Please select a customer first."), getLang("Info"));
                    return;
                }
                try {
                    const customer = await getCustomer(currentCustomerId);
                     // Ensure the selected customer still exists
                     if (!customer) {
                         customAlert(getLang("Selected customer not found. Please go back to the list."), getLang("Error"));
                         showCustomerListView();
                         return;
                     }

                    // Prepare and open the transaction modal
                    document.getElementById('transaction-form').reset(); // Clear previous entries
                    document.getElementById('transaction-customer-id').value = currentCustomerId; // Set hidden customer ID
                    document.getElementById('transaction-modal-customer-name').textContent = customer.name || 'Unnamed Customer'; // Display customer name

                    // Set default date to today in YYYY-MM-DD format
                     try {
                         const today = new Date();
                         // Adjust for timezone offset to get correct local date YYYY-MM-DD
                         today.setMinutes(today.getMinutes() - today.getTimezoneOffset());
                         document.getElementById('transaction-date').value = today.toISOString().split('T')[0];
                     } catch (e) {
                         console.error("Error setting default date:", e);
                         document.getElementById('transaction-date').value = ''; // Fallback
                     }
                    openModal('transaction-form-modal'); // Show the modal
                } catch (error) {
                    console.error("Error preparing transaction modal:", error);
                    customAlert(getLang("Error preparing transaction form."), getLang("Error"));
                }
            });

            // --- Transaction Filters (in Details View) ---

            // "Apply Filters" Button
            document.getElementById('apply-filters-btn').addEventListener('click', () => {
                 if (!currentCustomerId) return; // Should not happen if button is visible, but good practice
                 // Get filter values
                 const startDate = document.getElementById('filter-start-date').value;
                 const endDate = document.getElementById('filter-end-date').value;
                 const searchTerm = document.getElementById('transaction-search').value.trim();
                 // Reload transactions with the applied filters
                 loadTransactions(currentCustomerId, startDate || null, endDate || null, searchTerm || null);
            });

            // "Clear Filters" Button
            document.getElementById('clear-filters-btn').addEventListener('click', () => {
                 if (!currentCustomerId) return;
                 // Clear filter input fields
                 document.getElementById('filter-start-date').value = '';
                 document.getElementById('filter-end-date').value = '';
                 document.getElementById('transaction-search').value = '';
                 // Reload transactions without filters
                 loadTransactions(currentCustomerId);
            });

             // Transaction Search Input (Trigger filter on Enter key)
             document.getElementById('transaction-search').addEventListener('keypress', (e) => {
                 // Check if the key pressed was 'Enter'
                 if (e.key === 'Enter') {
                     e.preventDefault(); // Prevent potential form submission if wrapped in one
                     document.getElementById('apply-filters-btn').click(); // Simulate click on filter button
                 }
             });

             // --- Other Action Buttons (in Details View) ---

             // "Print Report" Button
             document.getElementById('print-report-btn').addEventListener('click', generateAndPrintReport);

             // "Send Reminder" Button
             document.getElementById('send-reminder-btn').addEventListener('click', generateReminder);

             // "Export CSV" Button
             document.getElementById('csv-export-btn').addEventListener('click', exportTransactionsToCSV);

             // --- Backup & Restore Buttons ---

             // "Backup Data" Button
             document.getElementById('backup-btn').addEventListener('click', backupData);

             // "Restore Data" File Input Change Event
             // The <label> acts as the button, this listens for file selection
             document.getElementById('restore-file').addEventListener('change', handleRestoreFile);

             // --- Language Switch Dropdown ---
             document.getElementById('language-switch').addEventListener('change', (e) => {
                 // Set the language based on the selected value
                 setLanguage(e.target.value);
             });
        }

        // --- Feature Implementations ---

        /**
         * Populates the customer form modal with existing customer data for editing.
         * @param {number} customerId - The ID of the customer to edit.
         */
        async function editCustomer(customerId) {
            try {
                const customer = await getCustomer(customerId);
                if (!customer) {
                    customAlert(getLang("Customer not found."), getLang("Error"));
                    return;
                }

                // Populate the form fields with the customer's data
                document.getElementById('customer-id').value = customer.id;
                document.getElementById('customer-name').value = customer.name || ''; // Handle potential null/undefined
                document.getElementById('customer-phone').value = customer.phone || '';
                document.getElementById('customer-address').value = customer.address || '';
                document.getElementById('customer-notes').value = customer.notes || '';

                // Set modal title for "Edit" mode and apply language
                const titleElement = document.getElementById('customer-modal-title');
                titleElement.dataset.en = 'Edit Customer';
                titleElement.dataset.ur = 'صارف میں ترمیم کریں';
                titleElement.textContent = getLang('Edit Customer'); // Set initial text
                setLanguage(currentLanguage); // Re-apply language

                openModal('customer-form-modal'); // Open the modal
            } catch (error) {
                console.error(`Error preparing edit for customer ${customerId}:`, error);
                customAlert(getLang("Error loading customer data for editing."), getLang("Error"));
            }
        }

        /**
         * Shows a confirmation dialog before deleting a customer.
         * Calls deleteCustomer if confirmed.
         * @param {number} customerId - The ID of the customer to potentially delete.
         */
        function confirmDeleteCustomer(customerId) {
             // Use the custom confirmation modal
             customConfirm(
                 // Confirmation message
                 getLang("Are you sure you want to delete this customer and all their transactions? This action cannot be undone."),
                 // Confirmation title
                 getLang("Confirm Deletion"),
                 // Callback function if confirmed
                 () => {
                     deleteCustomer(customerId); // Proceed with deletion
                 }
                 // No specific onCancel needed here, modal just closes
             );
        }

        /**
         * Generates the data needed for the printable report based on current filters.
         * Calculates opening balance, period totals, and closing balance.
         * @returns {Promise<object|null>} An object containing report data or null on error/no customer.
         */
        async function generateReportData() {
            if (!currentCustomerId) {
                customAlert(getLang("No customer selected for report."), getLang("Info"));
                return null;
            }

            try {
                const customer = await getCustomer(currentCustomerId);
                if (!customer) {
                    customAlert(getLang("Customer not found for report."), getLang("Error"));
                    return null;
                }

                // Get current filter values from the UI
                const startDate = document.getElementById('filter-start-date').value || null;
                const endDate = document.getElementById('filter-end-date').value || null;
                const searchTerm = document.getElementById('transaction-search').value.trim() || null;

                // --- Calculate Opening Balance ---
                let openingBalance = 0;
                if (startDate) {
                    // To get opening balance *for* the startDate, we need transactions *before* that date.
                    const dayBeforeStartDate = new Date(startDate + 'T00:00:00'); // Parse as local start of day
                    dayBeforeStartDate.setDate(dayBeforeStartDate.getDate() - 1); // Go to previous day
                    const endDateForOpening = dayBeforeStartDate.toISOString().split('T')[0]; // Format as YYYY-MM-DD

                    // Get all transactions up to the day *before* the selected start date
                    const transactionsBefore = await getTransactionsForCustomer(currentCustomerId, null, endDateForOpening);
                    // Sum their amounts to get the balance at the end of the previous day
                    transactionsBefore.forEach(tx => {
                         const amount = parseFloat(tx.amount);
                         if (!isNaN(amount)) {
                             openingBalance += (tx.type === 'udhaar' ? amount : -amount);
                         }
                     });
                }
                // If no startDate is selected, the opening balance relative to the start of records is 0.

                // --- Get Transactions Within the Period ---
                // Fetch transactions using the same filters applied in the UI
                const transactionsInPeriod = await getTransactionsForCustomer(currentCustomerId, startDate, endDate, searchTerm);

                // --- Calculate Period Totals and Prepare Report Rows ---
                let totalUdhaarInPeriod = 0;
                let totalPaymentInPeriod = 0;
                let currentRunningBalance = openingBalance; // Start running balance from the calculated opening balance

                const reportRows = transactionsInPeriod.map(tx => {
                    const amount = parseFloat(tx.amount);
                     if (isNaN(amount)) return null; // Skip transactions with invalid amounts

                    // Update period totals and the running balance for each transaction
                    if (tx.type === 'udhaar') {
                        totalUdhaarInPeriod += amount;
                        currentRunningBalance += amount;
                    } else { // type === 'payment'
                        totalPaymentInPeriod += amount;
                        currentRunningBalance -= amount;
                    }

                    // Return a formatted object for the report table row
                    return {
                        date: formatDate(tx.date),
                        type: tx.type === 'udhaar' ? getLang('Udhaar') : getLang('Payment'),
                        description: tx.description || '-',
                        udhaar: tx.type === 'udhaar' ? formatCurrency(amount) : '-', // Show amount in correct column
                        payment: tx.type === 'payment' ? formatCurrency(amount) : '-', // Show amount in correct column
                        balance: renderBalance(currentRunningBalance) // Show running balance after this transaction
                    };
                }).filter(row => row !== null); // Remove any skipped invalid transactions

                // The closing balance is the final running balance after processing all transactions in the period
                const closingBalance = currentRunningBalance;

                // Return all calculated data
                return {
                    customer,
                    startDate,
                    endDate,
                    transactions: reportRows, // Use the formatted rows
                    openingBalance,
                    totalUdhaar: totalUdhaarInPeriod,
                    totalPayment: totalPaymentInPeriod,
                    closingBalance
                };

            } catch (error) {
                console.error("Error generating report data:", error);
                customAlert(getLang("Error generating report data."), getLang("Error"));
                return null;
            }
        }


        /**
         * Generates report data, populates the printable report section, and triggers the browser's print dialog.
         */
        async function generateAndPrintReport() {
            // 1. Generate the necessary data
            const reportData = await generateReportData();
            if (!reportData) {
                // Error message already shown by generateReportData if needed
                return;
            }

            const { customer, startDate, endDate, transactions, openingBalance, totalUdhaar, totalPayment, closingBalance } = reportData;

            // 2. Populate the hidden printable report area (#printable-report-content)
            document.getElementById('report-customer-info').innerHTML = `
                <p><strong>${getLang('Customer')}:</strong> ${customer.name || 'Unnamed Customer'}</p>
                <p><strong>${getLang('Phone')}:</strong> ${customer.phone || '-'}</p>
            `;
            // Display the report period
            document.getElementById('report-period').innerHTML = `
                <p><strong>${getLang('Period')}:</strong>
                ${startDate ? formatDate(startDate) : getLang('Start')} ${getLang('to')} ${endDate ? formatDate(endDate) : getLang('End')}
                </p>
            `;

            // Populate the report table body
            const reportTableBody = document.getElementById('report-table-body');
            reportTableBody.innerHTML = ''; // Clear previous report content

            // Add Opening Balance Row
             const openingRow = reportTableBody.insertRow();
             openingRow.innerHTML = `
                 <td colspan="3" style="text-align: right;"><strong>${getLang('Opening Balance')}</strong></td>
                 <td></td> <td></td> <td><strong>${renderBalance(openingBalance)}</strong></td> `;
             openingRow.style.fontWeight = 'bold';
             openingRow.style.backgroundColor = '#f0f0f0'; // Light background for summary rows

            // Add transaction rows (data already formatted in reportData.transactions)
            transactions.forEach(tx => {
                const row = reportTableBody.insertRow();
                row.innerHTML = `
                    <td>${tx.date}</td>
                    <td>${tx.type}</td>
                    <td>${tx.description}</td>
                    <td>${tx.udhaar}</td>
                    <td>${tx.payment}</td>
                    <td>${tx.balance}</td>
                `;
                 // Apply Urdu font if needed (handled globally now)
                 // wrapUrduTextNodes(row);
            });

            // Add Summary Row for the period totals and closing balance
            const summaryRow = reportTableBody.insertRow();
            summaryRow.innerHTML = `
                <td colspan="3" style="text-align: right;"><strong>${getLang('Period Totals')}</strong></td>
                <td><strong>${formatCurrency(totalUdhaar)}</strong></td> <td><strong>${formatCurrency(totalPayment)}</strong></td> <td><strong>${renderBalance(closingBalance)}</strong></td> `;
            summaryRow.style.fontWeight = 'bold';
            summaryRow.style.backgroundColor = '#f0f0f0'; // Light background for summary rows

            // Populate the final summary section below the table (optional, can be redundant)
            document.getElementById('report-summary').innerHTML = `
                 <p><strong>${getLang('Opening Balance')}:</strong> ${renderBalance(openingBalance)}</p>
                 <p><strong>${getLang('Total Udhaar (Debit)')} (${getLang('Period')}):</strong> ${formatCurrency(totalUdhaar)}</p>
                 <p><strong>${getLang('Total Payment (Credit)')} (${getLang('Period')}):</strong> ${formatCurrency(totalPayment)}</p>
                 <p><strong>${getLang('Closing Balance')}:</strong> ${renderBalance(closingBalance)}</p>
            `;

            // Apply Urdu font if needed (handled globally now)
            // wrapUrduTextNodes(document.getElementById('printable-report-content'));


            // 3. Show the printable area and trigger print
            document.getElementById('printable-report-content').style.display = 'block';
            window.print(); // Open browser's print dialog

            // 4. Hide the printable area again after a short delay
            // This ensures it's hidden whether the user prints or cancels.
            setTimeout(() => {
                 document.getElementById('printable-report-content').style.display = 'none';
            }, 500); // 500ms delay
        }

        /**
         * Generates a payment reminder message and populates the reminder modal with WhatsApp/SMS links.
         */
        async function generateReminder() {
            if (!currentCustomerId) return; // Ensure customer is selected

            try {
                const customer = await getCustomer(currentCustomerId);
                // Check if customer exists and has a positive balance
                 if (!customer || isNaN(parseFloat(customer.balance)) || parseFloat(customer.balance) <= 0.005) {
                     customAlert(getLang("No reminder needed (balance is zero or negative) or customer not found."), getLang("Info"));
                     return;
                 }

                const balance = formatCurrency(customer.balance); // Formatted balance string
                // Allow customization of shop name via localStorage (could be set via a future settings feature)
                const shopName = localStorage.getItem('khataShopName') || getLang('Your Shop Name'); // Default shop name

                // Generate the reminder message using a template from translations
                const message = getLang('reminder_message_template')
                                    .replace('{customer_name}', customer.name || 'Customer') // Use 'Customer' if name is missing
                                    .replace('{balance_amount}', balance)
                                    .replace('{shop_name}', shopName);

                // Display the message in the modal
                document.getElementById('reminder-text').textContent = message;

                // --- Generate Communication Links ---
                const whatsappLinkElement = document.getElementById('whatsapp-link');
                const smsLinkElement = document.getElementById('sms-link');

                if (customer.phone) {
                     // Basic cleaning of the phone number (remove spaces, hyphens)
                     const cleanPhone = customer.phone.replace(/[-\s]/g, '');
                     // Attempt to format for WhatsApp/SMS (basic assumption: Pakistan +92)
                     // Remove leading 0 if adding 92, ensure it starts with country code
                     const whatsappNumber = cleanPhone.startsWith('+') ? cleanPhone : (cleanPhone.startsWith('92') ? cleanPhone : `92${cleanPhone.replace(/^0+/, '')}`);
                     const smsNumber = cleanPhone; // SMS often works without country code prefix depending on provider

                    // Create WhatsApp link (wa.me)
                    whatsappLinkElement.href = `https://wa.me/${whatsappNumber}?text=${encodeURIComponent(message)}`;
                    whatsappLinkElement.style.display = 'inline-block'; // Show button

                     // Create SMS link (sms:)
                     smsLinkElement.href = `sms:${smsNumber}?body=${encodeURIComponent(message)}`;
                     smsLinkElement.style.display = 'inline-block'; // Show button
                } else {
                     // Hide buttons if no phone number is available
                     whatsappLinkElement.style.display = 'none';
                     smsLinkElement.style.display = 'none';
                     // Append a note indicating no phone number
                     document.getElementById('reminder-text').textContent += `\n\n(${getLang('No phone number available for this customer.')})`;
                }

                // Apply Urdu font if needed (handled globally now)
                // wrapUrduTextNodes(document.getElementById('reminder-modal'));

                // Open the reminder modal
                openModal('reminder-modal');

            } catch (error) {
                console.error("Error generating reminder:", error);
                customAlert(getLang("Error generating reminder."), getLang("Error"));
            }
        }

        /**
         * Exports the currently filtered transactions for the selected customer to a CSV file.
         */
        async function exportTransactionsToCSV() {
             if (!currentCustomerId) {
                 customAlert(getLang("No customer selected for export."), getLang("Info"));
                 return;
             }

            try {
                const customer = await getCustomer(currentCustomerId);
                if (!customer) {
                    customAlert(getLang("Customer not found for export."), getLang("Error"));
                    return;
                }

                // Reuse the report generation logic to get filtered data and balances
                const reportData = await generateReportData();
                if (!reportData || reportData.transactions.length === 0) {
                    customAlert(getLang("No transactions to export for the selected criteria."), getLang("Info"));
                    return;
                }

                const { openingBalance, transactions, closingBalance, totalUdhaar, totalPayment } = reportData; // Get processed transactions and balances

                // --- Prepare CSV Content ---
                // Use Byte Order Mark (BOM) for better Excel compatibility with UTF-8 characters (like Urdu)
                let csvContent = "\uFEFF"; // BOM

                // Define CSV Headers using translated terms
                const headers = [
                    getLang("Date"),
                    getLang("Type"),
                    getLang("Description"),
                    getLang("Udhaar (Debit)"),
                    getLang("Payment (Credit)"),
                    getLang("Balance") // Running balance after transaction
                ];
                // Add headers to CSV, ensuring quotes handle commas within fields
                csvContent += headers.map(h => `"${h.replace(/"/g, '""')}"`).join(",") + "\r\n"; // Use CRLF line endings

                // Add Opening Balance Row
                 const openingBalanceRow = [
                     `"${formatDate(reportData.startDate || '')}"`, // Date (use start date of period or blank)
                     `"${getLang('Opening Balance')}"`, // Type
                     "", // Description
                     "", // Udhaar
                     "", // Payment
                     // Balance (remove HTML tags and quotes from rendered balance)
                     `"${renderBalance(openingBalance).replace(/<[^>]*>|"/g, '')}"`
                 ];
                 csvContent += openingBalanceRow.join(",") + "\r\n";


                // Add Transaction Rows from report data
                 transactions.forEach(tx => {
                     const row = [
                         `"${tx.date}"`,
                         `"${tx.type.replace(/"/g, '""')}"`, // Escape double quotes in type/description
                         `"${tx.description.replace(/"/g, '""')}"`,
                         // Extract only the numeric amount, remove currency symbol/parentheses
                         `"${tx.udhaar.replace(/[^0-9.-]/g, '')}"`,
                         `"${tx.payment.replace(/[^0-9.-]/g, '')}"`,
                         // Balance (remove HTML tags and quotes)
                         `"${tx.balance.replace(/<[^>]*>|"/g, '')}"`
                     ];
                     csvContent += row.join(",") + "\r\n";
                 });

                // Add Closing Balance / Summary Row
                 const closingBalanceRow = [
                     `"${formatDate(reportData.endDate || '')}"`, // Date (use end date of period or blank)
                     `"${getLang('Closing Balance')}"`, // Type
                     `"${getLang('Period Totals')}: ${getLang('Udhaar')}=${totalUdhaar.toFixed(2)}, ${getLang('Payment')}=${totalPayment.toFixed(2)}"`, // Description with totals
                     "", // Udhaar
                     "", // Payment
                     `"${renderBalance(closingBalance).replace(/<[^>]*>|"/g, '')}"` // Closing balance
                 ];
                 csvContent += closingBalanceRow.join(",") + "\r\n";


                // --- Create and Trigger Download ---
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement("a");
                link.setAttribute("href", url);
                // Generate filename (replace non-alphanumeric chars in name)
                const filename = `Khata_${(customer.name || 'Customer').replace(/[^a-z0-9]/gi, '_')}_${new Date().toISOString().split('T')[0]}.csv`;
                link.setAttribute("download", filename);
                link.style.visibility = 'hidden'; // Hide the link
                document.body.appendChild(link); // Append link to body (required for Firefox)
                link.click(); // Simulate click to trigger download
                document.body.removeChild(link); // Remove link from body
                URL.revokeObjectURL(url); // Clean up blob URL

                customAlert(getLang("CSV file generated successfully."), getLang("Export Successful"));

            } catch (error) {
                console.error("Error exporting CSV:", error);
                customAlert(getLang("Error exporting data to CSV."), getLang("Error"));
            }
        }


        /**
         * Backs up all customer and transaction data to a JSON file.
         * Includes metadata like version, date, language, and shop name.
         */
        async function backupData() {
            customAlert(getLang("Generating backup... Please wait."), getLang("In Progress"));
            try {
                // Fetch all data from IndexedDB
                const customers = await getAllObjects(CUSTOMERS_STORE_NAME);
                const transactions = await getAllObjects(TRANSACTIONS_STORE_NAME);

                // Create backup object structure
                const backup = {
                    version: 1, // Schema version for future compatibility
                    backupDate: new Date().toISOString(), // Timestamp of backup
                    language: currentLanguage, // Store current language setting
                    shopName: localStorage.getItem('khataShopName') || '', // Store shop name if set
                    customers: customers, // Array of customer objects
                    transactions: transactions // Array of transaction objects
                };

                // Convert backup object to a pretty-printed JSON string
                const jsonString = JSON.stringify(backup, null, 2);
                // Create a Blob from the JSON string
                const blob = new Blob([jsonString], { type: 'application/json' });
                // Create a temporary URL for the Blob
                const url = URL.createObjectURL(blob);

                // Create a link element to trigger the download
                const link = document.createElement('a');
                link.href = url;
                // Generate filename with timestamp
                const filename = `DigitalKhata_Backup_${new Date().toISOString().split('T')[0].replace(/-/g,'')}.json`;
                link.download = filename;
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click(); // Trigger download
                document.body.removeChild(link);
                URL.revokeObjectURL(url); // Clean up blob URL

                // Close the "in progress" alert and show success
                closeModal('alert-modal');
                customAlert(getLang("Backup successful! Keep the downloaded file safe."), getLang("Backup Complete"));

            } catch (error) {
                console.error("Backup failed:", error);
                 // Close the "in progress" alert and show error
                closeModal('alert-modal');
                customAlert(`${getLang("Backup failed:")} ${error.message}`, getLang("Error"));
            }
        }

        /**
         * Handles the file selection event for restoring data.
         * Reads the selected JSON file and asks for confirmation.
         * @param {Event} event - The file input change event.
         */
        function handleRestoreFile(event) {
            const fileInput = event.target;
            const file = fileInput.files[0];
            if (!file) return; // No file selected

            const reader = new FileReader();

            // Define what happens when the file is successfully read
            reader.onload = (e) => {
                try {
                    const backupData = JSON.parse(e.target.result);
                    // Basic validation of the backup file structure
                     if (typeof backupData !== 'object' || !backupData.customers || !backupData.transactions || !backupData.version) {
                         throw new Error(getLang("Invalid backup file structure or missing data."));
                     }
                     if (backupData.version !== 1) {
                         // Handle different versions in the future if needed
                         console.warn(`Backup file version ${backupData.version} might not be fully compatible.`);
                     }

                    // Ask for confirmation before proceeding with the restore
                    customConfirm(
                        getLang("Restoring will overwrite ALL current data (customers and transactions). This action cannot be undone. Are you sure you want to proceed?"),
                        getLang("Confirm Restore"),
                        () => { // onConfirm: Proceed with restore
                            restoreData(backupData);
                        },
                        () => { // onCancel: Reset the file input
                            fileInput.value = ''; // Clear the selected file
                        }
                    );
                } catch (error) {
                    console.error("Error reading or parsing restore file:", error);
                     customAlert(`${getLang("Error reading restore file:")} ${error.message}`, getLang("Error"));
                    fileInput.value = ''; // Reset file input on error
                }
            };

            // Define what happens if there's an error reading the file
            reader.onerror = () => {
                 customAlert(getLang("Failed to read the selected file."), getLang("File Read Error"));
                 fileInput.value = ''; // Reset file input on error
            };

            // Read the file as text
            reader.readAsText(file);
        }

        /**
         * Restores data from a backup object. Clears existing data first.
         * Maps old customer IDs to new IDs and updates transactions accordingly.
         * Recalculates all balances after restoring.
         * @param {object} backupData - The parsed backup data object.
         */
        async function restoreData(backupData) {
             if (!db) {
                 customAlert(getLang("Database not initialized. Cannot restore."), getLang("Error"));
                 return;
             }
             customAlert(getLang("Restoring data... This may take a moment. Please wait."), getLang("In Progress"));

             try {
                 // --- Step 1: Clear existing data from both stores ---
                 console.log("Clearing existing data...");
                 const storesToClear = [CUSTOMERS_STORE_NAME, TRANSACTIONS_STORE_NAME];
                 const clearTx = db.transaction(storesToClear, 'readwrite');
                 const clearPromises = storesToClear.map(storeName => {
                     return new Promise((resolve, reject) => {
                         const request = clearTx.objectStore(storeName).clear();
                         request.onsuccess = resolve;
                         request.onerror = (e) => reject(`Failed to clear ${storeName}: ${e.target.error}`);
                     });
                 });
                 await Promise.all(clearPromises); // Wait for both clear operations
                 await new Promise(resolve => clearTx.oncomplete = resolve); // Wait for transaction to complete
                 console.log("Old data cleared.");

                 // --- Step 2: Restore Customers and create an ID map ---
                 console.log("Restoring customers...");
                 const customerIdMap = new Map(); // To map old customer IDs to new auto-incremented IDs
                 const addCustomersTx = db.transaction(CUSTOMERS_STORE_NAME, 'readwrite');
                 const addCustomersStore = addCustomersTx.objectStore(CUSTOMERS_STORE_NAME);
                 const customerAddPromises = backupData.customers.map(customer => {
                     return new Promise(async (resolve, reject) => {
                         const oldId = customer.id; // Store the original ID from the backup
                         delete customer.id; // Remove old ID so IndexedDB generates a new one
                         // Balance might be incorrect in backup, will be recalculated later
                         customer.balance = 0; // Reset balance initially
                         const addRequest = addCustomersStore.add(customer);
                         addRequest.onsuccess = (e) => {
                             const newId = e.target.result; // Get the new auto-generated ID
                             if (oldId !== undefined && newId !== undefined) {
                                 customerIdMap.set(oldId, newId); // Map the old ID to the new ID
                             }
                             resolve();
                         };
                         addRequest.onerror = (e) => {
                              console.error(`Failed to add customer (Old ID: ${oldId}, Name: ${customer.name}): ${e.target.error}`);
                              // Decide whether to reject all or just skip this customer
                              reject(e.target.error); // Rejecting stops the whole restore here
                         };
                     });
                 });
                 await Promise.all(customerAddPromises); // Wait for all customers to be added
                 await new Promise(resolve => addCustomersTx.oncomplete = resolve); // Wait for transaction to complete
                 console.log(`Customers restored. ${customerIdMap.size} ID mappings created.`);

                 // --- Step 3: Restore Transactions, updating customerId using the map ---
                 console.log("Restoring transactions...");
                 const addTransactionsTx = db.transaction(TRANSACTIONS_STORE_NAME, 'readwrite');
                 const addTransactionsStore = addTransactionsTx.objectStore(TRANSACTIONS_STORE_NAME);
                  let transactionsAdded = 0;
                  let transactionsSkipped = 0;
                  const transactionAddPromises = backupData.transactions.map(transaction => {
                      return new Promise((resolve, reject) => {
                          const oldCustomerId = transaction.customerId;
                          const newCustomerId = customerIdMap.get(oldCustomerId); // Find the new customer ID from the map

                          if (newCustomerId !== undefined) {
                              delete transaction.id; // Remove old transaction ID
                              delete transaction.balanceAfter; // Remove old calculated balance
                              transaction.customerId = newCustomerId; // Update to the new customer ID
                              const addTxRequest = addTransactionsStore.add(transaction);
                              addTxRequest.onsuccess = () => {
                                  transactionsAdded++;
                                  resolve();
                              };
                              addTxRequest.onerror = (e) => {
                                  console.error(`Failed to add transaction (Old Cust ID: ${oldCustomerId}, New Cust ID: ${newCustomerId}): ${e.target.error}`);
                                  transactionsSkipped++; // Count skipped but resolve to continue restore
                                  resolve(); // Resolve even on error to not block Promise.all entirely
                              };
                          } else {
                              console.warn(`Skipping transaction (Old ID: ${transaction.id}) because old customer ID ${oldCustomerId} was not found in the map.`);
                              transactionsSkipped++;
                              resolve(); // Resolve to continue
                          }
                      });
                  });
                 await Promise.all(transactionAddPromises); // Wait for all transaction adds/skips
                 await new Promise(resolve => addTransactionsTx.oncomplete = resolve); // Wait for transaction to complete
                 console.log(`Transactions restored: ${transactionsAdded} added, ${transactionsSkipped} skipped.`);

                 // --- Step 4: Recalculate all customer balances based on restored transactions ---
                 console.log("Recalculating all customer balances...");
                 const allRestoredCustomers = await getAllObjects(CUSTOMERS_STORE_NAME);
                 const balanceUpdatePromises = allRestoredCustomers.map(customer => updateCustomerBalance(customer.id));
                 await Promise.all(balanceUpdatePromises);
                 console.log("Balances recalculated.");

                 // --- Step 5: Restore Settings (Language, Shop Name) ---
                 if (backupData.language) {
                     setLanguage(backupData.language); // Apply restored language
                     document.getElementById('language-switch').value = backupData.language; // Update dropdown
                 }
                 if (backupData.shopName) {
                     localStorage.setItem('khataShopName', backupData.shopName);
                 }

                 // --- Final Step: Update UI and Notify User ---
                 closeModal('alert-modal'); // Close the "In Progress" alert
                 customAlert(getLang("Data restored successfully. Balances recalculated."), getLang("Restore Complete"));
                 await loadCustomers(); // Reload UI with restored data
                 await updateDashboard();
                 showCustomerListView(); // Go back to main view

             } catch (error) {
                 console.error("Restore failed:", error);
                 closeModal('alert-modal'); // Close the "In Progress" alert
                 customAlert(`${getLang("Restore failed:")} ${error.message || error}`, getLang("Error"));
                 // Attempt to reload existing data if restore failed midway (might be inconsistent)
                 await loadCustomers();
                 await updateDashboard();
             } finally {
                 // Reset the file input regardless of success or failure
                 document.getElementById('restore-file').value = '';
             }
        }


        // --- Language Switching ---

        // Translation dictionary
        const translations = {
            en: {
                "Digital Khata": "Digital Khata", "Dashboard": "Dashboard", "Total Customers": "Total Customers",
                "Total Balance (Lena Hai)": "Total Balance (Lena Hai)", "Total Advance (Dena Hai)": "Total Advance (Dena Hai)",
                "Customers": "Customers", "Add New Customer": "Add New Customer", "Search Customers...": "Search Customers...",
                "Name": "Name", "Phone": "Phone", "Balance": "Balance", "Actions": "Actions",
                "No customers found.": "No customers found.", "No customers match your search.": "No customers match your search.",
                "Edit": "Edit", "Delete": "Delete", "Backup & Restore": "Backup & Restore",
                "Backup Data (JSON)": "Backup Data (JSON)", "Restore Data (JSON)": "Restore Data (JSON)",
                "Customer Details": "Customer Details", "Back to List": "Back to List", "Address": "Address",
                "Notes": "Notes", "Current Balance:": "Current Balance:", "Transactions": "Transactions",
                "Add Transaction": "Add Transaction", "Send Reminder": "Send Reminder", "Print Report": "Print Report",
                "Export CSV": "Export CSV", "From:": "From:", "To:": "To:", "Search Description...": "Search Description...",
                "Filter": "Filter", "Clear": "Clear", "Date": "Date", "Type": "Type", "Description": "Description",
                "Amount": "Amount", "No transactions found for the selected criteria.": "No transactions found for the selected criteria.",
                "Monthly Statement": "Monthly Statement", "Customer": "Customer", "Period": "Period", "Start": "Start",
                "to": "to", "End": "End", "Udhaar (Debit)": "Udhaar (Debit)", "Payment (Credit)": "Payment (Credit)",
                "Opening Balance": "Opening Balance", "Period Totals": "Period Totals", "Total Udhaar (Debit)": "Total Udhaar (Debit)",
                "Total Payment (Credit)": "Total Payment (Credit)", "Closing Balance": "Closing Balance",
                "Edit Customer": "Edit Customer", "Phone (Optional)": "Phone (Optional)", "Address (Optional)": "Address (Optional)",
                "Notes (Optional)": "Notes (Optional)", "Save Customer": "Save Customer", "Cancel": "Cancel",
                "Add Transaction for": "Add Transaction for", "Transaction Type": "Transaction Type",
                "Udhaar (You Gave / Lena Hai)": "Udhaar (You Gave / Lena Hai)", "Payment (You Received / Jama)": "Payment (You Received / Jama)",
                "Amount (Rs)": "Amount (Rs)", "Payment Method (Optional)": "Payment Method (Optional)",
                "Select Method": "Select Method", "Cash": "Cash", "JazzCash": "JazzCash", "EasyPaisa": "EasyPaisa",
                "Bank Transfer": "Bank Transfer", "Other": "Other", "Description (Optional)": "Description (Optional)",
                "Save Transaction": "Save Transaction", "Send Payment Reminder": "Send Payment Reminder",
                "Send via WhatsApp": "Send via WhatsApp", "Send via SMS": "Send via SMS", "Close": "Close",
                "Alert": "Alert", "OK": "OK", "Confirm": "Confirm", "Customer name is required.": "Customer name is required.",
                "Validation Error": "Validation Error", "Customer updated successfully.": "Customer updated successfully.",
                "Success": "Success", "Customer added successfully.": "Customer added successfully.",
                "Error saving customer:": "Error saving customer:", "Error": "Error", "An unknown error occurred.": "An unknown error occurred.",
                "A potential conflict occurred. Please check the data.": "A potential conflict occurred. Please check the data.",
                "Please enter a valid positive amount.": "Please enter a valid positive amount.",
                "Please select a transaction date.": "Please select a transaction date.", "Invalid customer ID.": "Invalid customer ID.",
                "Transaction added successfully.": "Transaction added successfully.", "Error saving transaction:": "Error saving transaction:",
                "Are you sure you want to delete this customer and all their transactions? This action cannot be undone.": "Are you sure you want to delete this customer and all their transactions? This action cannot be undone.",
                "Confirm Deletion": "Confirm Deletion", "Customer and all related transactions deleted.": "Customer and all related transactions deleted.",
                "Deleted": "Deleted", "Customer not found.": "Customer not found.", "Error loading customer details:": "Error loading customer details:",
                "Error loading transactions:": "Error loading transactions:", "Error updating dashboard:": "Error updating dashboard:",
                "Could not generate report data.": "Could not generate report data.", "No customer selected for report.": "No customer selected for report.",
                "Customer not found for report.": "Customer not found for report.", "Error generating report data.": "Error generating report data.",
                "No reminder needed (balance is zero or negative) or customer not found.": "No reminder needed (balance is zero or negative) or customer not found.",
                "No phone number available for this customer.": "No phone number available for this customer.", "Info": "Info",
                "reminder_message_template": "Dear {customer_name},\n\nThis is a friendly reminder regarding your outstanding balance of {balance_amount} with {shop_name}.\n\nPlease clear it at your earliest convenience.\n\nThank you.",
                "Your Shop Name": "Your Shop Name", "No transactions to export for the selected criteria.": "No transactions to export for the selected criteria.",
                "CSV file generated successfully.": "CSV file generated successfully.", "Export Successful": "Export Successful",
                "Error exporting data to CSV.": "Error exporting data to CSV.", "No customer selected for export.": "No customer selected for export.",
                "Customer not found for export.": "Customer not found for export.",
                "Generating backup... Please wait.": "Generating backup... Please wait.", "In Progress": "In Progress",
                "Backup successful! Keep the downloaded file safe.": "Backup successful! Keep the downloaded file safe.",
                "Backup Complete": "Backup Complete", "Backup failed:": "Backup failed:",
                "Invalid backup file structure or missing data.": "Invalid backup file structure or missing data.",
                "Restoring will overwrite ALL current data (customers and transactions). This action cannot be undone. Are you sure you want to proceed?": "Restoring will overwrite ALL current data (customers and transactions). This action cannot be undone. Are you sure you want to proceed?",
                "Confirm Restore": "Confirm Restore", "Error reading or parsing restore file:": "Error reading or parsing restore file:",
                "Error reading restore file:": "Error reading restore file:", "Failed to read the selected file.": "Failed to read the selected file.",
                "File Read Error": "File Read Error", "Database not initialized. Cannot restore.": "Database not initialized. Cannot restore.",
                "Restoring data... This may take a moment. Please wait.": "Restoring data... This may take a moment. Please wait.",
                "Data restored successfully. Balances recalculated.": "Data restored successfully. Balances recalculated.",
                "Restore Complete": "Restore Complete", "Restore failed:": "Restore failed:", "Language": "Language",
                "Udhaar": "Udhaar", "Payment": "Payment", "Lena Hai": "Lena Hai", "Dena Hai": "Dena Hai", "Settled": "Settled",
                "Error opening database. Please ensure IndexedDB is enabled and not in private browsing.": "Error opening database. Please ensure IndexedDB is enabled and not in private browsing.",
                "Database Error": "Database Error", "Initialization Failed": "Initialization Failed",
                "Could not initialize the application database.": "Could not initialize the application database.",
                "Please ensure you are not in private browsing mode and that your browser supports IndexedDB.": "Please ensure you are not in private browsing mode and that your browser supports IndexedDB.",
                "Error details:": "Error details:", "Error loading customer data for editing.": "Error loading customer data for editing.",
                "Please select a customer first.": "Please select a customer first.", "Selected customer not found. Please go back to the list.": "Selected customer not found. Please go back to the list.",
                "Error preparing transaction form.": "Error preparing transaction form.", "Error generating reminder.": "Error generating reminder.",
                "Error loading customers:": "Error loading customers:", "Error loading customers.": "Error loading customers.",
                "Error loading transactions.": "Error loading transactions."
            },
            ur: { // Urdu Translations (ensure accuracy)
                "Digital Khata": "ڈیجیٹل کھاتہ", "Dashboard": "ڈیش بورڈ", "Total Customers": "کل صارفین",
                "Total Balance (Lena Hai)": "کل بیلنس (لینا ہے)", "Total Advance (Dena Hai)": "کل ایڈوانس (دینا ہے)",
                "Customers": "صارفین", "Add New Customer": "نیا صارف شامل کریں", "Search Customers...": "صارفین تلاش کریں...",
                "Name": "نام", "Phone": "فون", "Balance": "بیلنس", "Actions": "کاروائیاں",
                "No customers found.": "کوئی صارف نہیں ملا۔", "No customers match your search.": "آپ کی تلاش سے مماثل کوئی صارف نہیں ملا۔",
                "Edit": "ترمیم", "Delete": "حذف کریں", "Backup & Restore": "بیک اپ اور بحال کریں",
                "Backup Data (JSON)": "ڈیٹا بیک اپ (JSON)", "Restore Data (JSON)": "ڈیٹا بحال کریں (JSON)",
                "Customer Details": "صارف کی تفصیلات", "Back to List": "فہرست پر واپس", "Address": "پتہ",
                "Notes": "نوٹس", "Current Balance:": "موجودہ بیلنس:", "Transactions": "لین دین",
                "Add Transaction": "لین دین شامل کریں", "Send Reminder": "یاد دہانی بھیجیں", "Print Report": "رپورٹ پرنٹ کریں",
                "Export CSV": "CSV ایکسپورٹ کریں", "From:": "سے:", "To:": "تک:", "Search Description...": "تفصیل تلاش کریں...",
                "Filter": "فلٹر کریں", "Clear": "صاف کریں", "Date": "تاریخ", "Type": "قسم", "Description": "تفصیل",
                "Amount": "رقم", "No transactions found for the selected criteria.": "منتخب کردہ معیار کے لئے کوئی لین دین نہیں ملا۔",
                "Monthly Statement": "ماہانہ گوشوارہ", "Customer": "صارف", "Period": "مدت", "Start": "شروع",
                "to": "تک", "End": "اختتام", "Udhaar (Debit)": "ادھار (لینا ہے)", "Payment (Credit)": "وصولی (جمع)",
                "Opening Balance": "ابتدائی بیلنس", "Period Totals": "مدت کا میزان", "Total Udhaar (Debit)": "کل ادھار (لینا ہے)",
                "Total Payment (Credit)": "کل وصولی (جمع)", "Closing Balance": "اختتامی بیلنس",
                "Edit Customer": "صارف میں ترمیم کریں", "Phone (Optional)": "فون (اختیاری)", "Address (Optional)": "پتہ (اختیاری)",
                "Notes (Optional)": "نوٹس (اختیاری)", "Save Customer": "صارف محفوظ کریں", "Cancel": "منسوخ کریں",
                "Add Transaction for": "کے لیے لین دین شامل کریں", "Transaction Type": "لین دین کی قسم",
                "Udhaar (You Gave / Lena Hai)": "ادھار (آپ نے دیا / لینا ہے)", "Payment (You Received / Jama)": "وصولی (آپ نے وصول کیا / جمع)",
                "Amount (Rs)": "رقم (روپے)", "Payment Method (Optional)": "ادائیگی کا طریقہ (اختیاری)",
                "Select Method": "طریقہ منتخب کریں", "Cash": "نقد", "JazzCash": "جاز کیش", "EasyPaisa": "ایزی پیسہ",
                "Bank Transfer": "بینک ٹرانسفر", "Other": "دیگر", "Description (Optional)": "تفصیل (اختیاری)",
                "Save Transaction": "لین دین محفوظ کریں", "Send Payment Reminder": "ادائیگی کی یاد دہانی بھیجیں",
                "Send via WhatsApp": "واٹس ایپ پر بھیجیں", "Send via SMS": "ایس ایم ایس پر بھیجیں", "Close": "بند کریں",
                "Alert": "انتباہ", "OK": "ٹھیک ہے", "Confirm": "تصدیق کریں", "Customer name is required.": "صارف کا نام درکار ہے۔",
                "Validation Error": "توثیق کی خرابی", "Customer updated successfully.": "صارف کامیابی سے اپ ڈیٹ ہو گیا۔",
                "Success": "کامیابی", "Customer added successfully.": "صارف کامیابی سے شامل ہو گیا۔",
                "Error saving customer:": "صارف کو محفوظ کرنے میں خرابی:", "Error": "خرابی", "An unknown error occurred.": "ایک نامعلوم خرابی پیش آگئی۔",
                "A potential conflict occurred. Please check the data.": "ایک ممکنہ تصادم واقع ہوا۔ براہ کرم ڈیٹا چیک کریں۔",
                "Please enter a valid positive amount.": "براہ کرم ایک درست مثبت رقم درج کریں۔",
                "Please select a transaction date.": "براہ کرم لین دین کی تاریخ منتخب کریں۔", "Invalid customer ID.": "غلط صارف ID۔",
                "Transaction added successfully.": "لین دین کامیابی سے شامل ہو گیا۔", "Error saving transaction:": "لین دین کو محفوظ کرنے میں خرابی:",
                "Are you sure you want to delete this customer and all their transactions? This action cannot be undone.": "کیا آپ واقعی اس صارف اور ان کے تمام لین دین کو حذف کرنا چاہتے ہیں؟ یہ عمل واپس نہیں لیا جا سکتا۔",
                "Confirm Deletion": "حذف کرنے کی تصدیق کریں", "Customer and all related transactions deleted.": "صارف اور تمام متعلقہ لین دین حذف کر دیے گئے۔",
                "Deleted": "حذف کر دیا گیا۔", "Customer not found.": "صارف نہیں ملا۔", "Error loading customer details:": "صارف کی تفصیلات لوڈ کرنے میں خرابی:",
                "Error loading transactions:": "لین دین لوڈ کرنے میں خرابی:", "Error updating dashboard:": "ڈیش بورڈ اپ ڈیٹ کرنے میں خرابی:",
                "Could not generate report data.": "رپورٹ کا ڈیٹا تیار نہیں کیا جا سکا۔", "No customer selected for report.": "رپورٹ کے لیے کوئی صارف منتخب نہیں کیا گیا۔",
                "Customer not found for report.": "رپورٹ کے لیے صارف نہیں ملا۔", "Error generating report data.": "رپورٹ کا ڈیٹا تیار کرنے میں خرابی۔",
                "No reminder needed (balance is zero or negative) or customer not found.": "یاد دہانی کی ضرورت نہیں (بیلنس صفر یا منفی ہے) یا صارف نہیں ملا۔",
                "No phone number available for this customer.": "اس صارف کے لیے کوئی فون نمبر دستیاب نہیں ہے۔", "Info": "معلومات",
                "reminder_message_template": "محترم {customer_name}،\n\nیہ {shop_name} کے ساتھ آپ کے بقایا بیلنس {balance_amount} کے بارے میں ایک دوستانہ یاد دہانی ہے۔\n\nبراہ کرم جلد از جلد اسے ادا کریں۔\n\nشکریہ۔",
                "Your Shop Name": "آپکی دکان کا نام", "No transactions to export for the selected criteria.": "منتخب کردہ معیار کے لیے برآمد کرنے کے لیے کوئی لین دین نہیں ہے۔",
                "CSV file generated successfully.": "CSV فائل کامیابی سے تیار ہو گئی۔", "Export Successful": "برآمد کامیاب",
                "Error exporting data to CSV.": "ڈیٹا کو CSV میں برآمد کرنے میں خرابی۔", "No customer selected for export.": "برآمد کے لیے کوئی صارف منتخب نہیں کیا گیا۔",
                "Customer not found for export.": "برآمد کے لیے صارف نہیں ملا۔",
                "Generating backup... Please wait.": "بیک اپ تیار کیا جا رہا ہے۔۔۔ براہ کرم انتظار کریں۔", "In Progress": "جاری ہے",
                "Backup successful! Keep the downloaded file safe.": "بیک اپ کامیاب! ڈاؤن لوڈ کی گئی فائل کو محفوظ رکھیں۔",
                "Backup Complete": "بیک اپ مکمل", "Backup failed:": "بیک اپ ناکام:",
                "Invalid backup file structure or missing data.": "بیک اپ فائل کا ڈھانچہ غلط ہے یا ڈیٹا غائب ہے۔",
                "Restoring will overwrite ALL current data (customers and transactions). This action cannot be undone. Are you sure you want to proceed?": "بحال کرنے سے موجودہ تمام ڈیٹا (صارفین اور لین دین) اوور رائٹ ہو جائے گا۔ یہ عمل واپس نہیں لیا جا سکتا۔ کیا آپ واقعی آگے بڑھنا چاہتے ہیں؟",
                "Confirm Restore": "بحالی کی تصدیق کریں", "Error reading or parsing restore file:": "بحالی فائل کو پڑھنے یا پارس کرنے میں خرابی:",
                "Error reading restore file:": "بحالی فائل کو پڑھنے میں خرابی:", "Failed to read the selected file.": "منتخب فائل کو پڑھنے میں ناکامی۔",
                "File Read Error": "فائل پڑھنے میں خرابی", "Database not initialized. Cannot restore.": "ڈیٹا بیس شروع نہیں ہوا۔ بحال نہیں کیا جا سکتا۔",
                "Restoring data... This may take a moment. Please wait.": "ڈیٹا بحال کیا جا رہا ہے۔۔۔ اس میں کچھ وقت لگ سکتا ہے۔ براہ کرم انتظار کریں۔",
                "Data restored successfully. Balances recalculated.": "ڈیٹا کامیابی سے بحال ہو گیا۔ بیلنس دوبارہ کیلکولیٹ کر دیے گئے ہیں۔",
                "Restore Complete": "بحالی مکمل", "Restore failed:": "بحالی ناکام:", "Language": "زبان",
                "Udhaar": "ادھار", "Payment": "وصولی", "Lena Hai": "لینا ہے", "Dena Hai": "دینا ہے", "Settled": "حساب برابر",
                "Error opening database. Please ensure IndexedDB is enabled and not in private browsing.": "ڈیٹا بیس کھولنے میں خرابی۔ براہ کرم یقینی بنائیں کہ IndexedDB فعال ہے اور نجی براؤزنگ میں نہیں ہے۔",
                "Database Error": "ڈیٹا بیس کی خرابی", "Initialization Failed": "شروع کرنے میں ناکامی",
                "Could not initialize the application database.": "ایپلیکیشن ڈیٹا بیس کو شروع نہیں کیا جا سکا۔",
                "Please ensure you are not in private browsing mode and that your browser supports IndexedDB.": "براہ کرم یقینی بنائیں کہ آپ نجی براؤزنگ موڈ میں نہیں ہیں اور آپ کا براؤزر IndexedDB کو سپورٹ کرتا ہے۔",
                "Error details:": "خرابی کی تفصیلات:", "Error loading customer data for editing.": "ترمیم کے لیے صارف کا ڈیٹا لوڈ کرنے میں خرابی۔",
                "Please select a customer first.": "براہ کرم پہلے ایک صارف منتخب کریں۔", "Selected customer not found. Please go back to the list.": "منتخب صارف نہیں ملا۔ براہ کرم فہرست پر واپس جائیں۔",
                "Error preparing transaction form.": "لین دین فارم تیار کرنے میں خرابی۔", "Error generating reminder.": "یاد دہانی تیار کرنے میں خرابی۔",
                "Error loading customers:": "صارفین کو لوڈ کرنے میں خرابی:", "Error loading customers.": "صارفین کو لوڈ کرنے میں خرابی۔",
                "Error loading transactions.": "لین دین لوڈ کرنے میں خرابی۔"
            }
        };

        /**
         * Gets the translated string for a given key in the current language.
         * Falls back to English if the key is not found in the current language.
         * @param {string} key - The translation key (usually the English text).
         * @returns {string} The translated string or the key itself if no translation found.
         */
        function getLang(key) {
            // Use optional chaining for safer access
            return translations[currentLanguage]?.[key] // Try current language
                   || translations['en']?.[key]         // Fallback to English
                   || key;                             // Fallback to the key itself
        }

        /**
         * Applies the selected language to all relevant UI elements.
         * Updates text content, placeholders, and potentially re-renders dynamic content.
         * @param {string} lang - The language code ('en' or 'ur').
         */
        function setLanguage(lang) {
            currentLanguage = lang; // Update global language variable
            localStorage.setItem('khataLanguage', lang); // Save preference for next visit
            document.documentElement.lang = lang; // Set 'lang' attribute on <html> tag
            document.documentElement.dir = lang === 'ur' ? 'rtl' : 'ltr'; // Set text direction (right-to-left for Urdu)

            // Select all elements that have language data attributes
            const elements = document.querySelectorAll('[data-en]'); // Use data-en as the key source

            elements.forEach(el => {
                const key = el.dataset.en; // The English text acts as the key
                const translatedText = getLang(key); // Get translation using the helper

                // --- Apply Translation Based on Element Type ---

                // Handle input placeholders
                if ((el.tagName === 'INPUT' || el.tagName === 'TEXTAREA') && el.placeholder) {
                     // Use a specific placeholder key if available (e.g., data-en-placeholder)
                    const placeholderKey = el.dataset.enPlaceholder || key;
                    const translatedPlaceholder = getLang(placeholderKey);
                    el.placeholder = translatedPlaceholder;
                }
                // Handle button values (though textContent is usually preferred)
                else if (el.tagName === 'INPUT' && (el.type === 'button' || el.type === 'submit')) {
                    el.value = translatedText;
                }
                // Handle dropdown options
                else if (el.tagName === 'OPTION') {
                     // Check if the option itself has a key, otherwise use its default text as key
                     const optionKey = el.dataset.en || el.textContent.trim();
                     el.textContent = getLang(optionKey);
                }
                 // Handle regular elements (headings, labels, spans, buttons, etc.)
                 else {
                     // Only update if the direct child is a text node or if it's empty
                     // This avoids replacing complex inner HTML (like icons within buttons)
                     // A more robust solution might involve marking specific text spans for translation.
                     if (el.childNodes.length === 0 || (el.childNodes.length === 1 && el.firstChild.nodeType === Node.TEXT_NODE)) {
                        el.textContent = translatedText;
                     } else {
                         // If element has complex children, try to find a text node to update
                         // This is a basic attempt, might need refinement for complex structures
                         for (let i = 0; i < el.childNodes.length; i++) {
                             if (el.childNodes[i].nodeType === Node.TEXT_NODE && el.childNodes[i].textContent.trim().length > 0) {
                                 el.childNodes[i].textContent = translatedText;
                                 break; // Assume first text node is the target
                             }
                         }
                     }
                 }
            });

             // --- Force Urdu Font Application ---
             // Re-apply Urdu font class to elements containing Urdu characters after text updates
             wrapUrduTextNodes(document.body);


             // --- Refresh Dynamic Content ---
             // Reloading data ensures dynamic parts like formatted dates and balances use the new language strings.
             if (currentCustomerId) {
                 // If viewing details, reload that specific customer's details and transactions
                 loadCustomerDetails(currentCustomerId);
             } else {
                 // If on the list view, reload the customer list and the dashboard summary
                 loadCustomers(document.getElementById('customer-search').value.trim()); // Reload list with current search term
                 updateDashboard();
             }

             // Ensure the language dropdown itself shows the correct selection
             document.getElementById('language-switch').value = lang;
        }

        // --- Custom Alert/Confirm Modals ---

        /**
         * Displays a simple alert message using the custom modal.
         * @param {string} message - The message to display (should be pre-translated if needed).
         * @param {string} [titleKey="Alert"] - The translation key for the modal title.
         */
        function customAlert(message, titleKey = "Alert") {
            document.getElementById('alert-title').textContent = getLang(titleKey); // Translate title
            document.getElementById('alert-message').textContent = message; // Assume message is already translated or language-neutral
            // Configure buttons for ALERT mode
            document.getElementById('alert-confirm-btn').style.display = 'none';
            document.getElementById('alert-cancel-btn').style.display = 'none';
            document.getElementById('alert-ok-btn').style.display = 'inline-block';
            document.getElementById('alert-ok-btn').textContent = getLang("OK"); // Translate OK button
            // Clear any previous confirm/cancel listeners
            document.getElementById('alert-confirm-btn').onclick = null;
            document.getElementById('alert-cancel-btn').onclick = null;
            openModal('alert-modal');
        }

        /**
         * Displays a confirmation dialog using the custom modal.
         * @param {string} message - The confirmation message (should be pre-translated).
         * @param {string} [titleKey="Confirm"] - The translation key for the modal title.
         * @param {function} onConfirm - Callback function to execute if the user confirms.
         * @param {function | null} [onCancel=null] - Optional callback function if the user cancels.
         */
        function customConfirm(message, titleKey = "Confirm", onConfirm, onCancel = null) {
            document.getElementById('alert-title').textContent = getLang(titleKey); // Translate title
            document.getElementById('alert-message').textContent = message; // Assume message is pre-translated
            // Configure buttons for CONFIRM mode
            document.getElementById('alert-ok-btn').style.display = 'none';
            document.getElementById('alert-confirm-btn').style.display = 'inline-block';
            document.getElementById('alert-cancel-btn').style.display = 'inline-block';
            document.getElementById('alert-confirm-btn').textContent = getLang("Confirm"); // Translate Confirm button
            document.getElementById('alert-cancel-btn').textContent = getLang("Cancel"); // Translate Cancel button

            const confirmBtn = document.getElementById('alert-confirm-btn');
            const cancelBtn = document.getElementById('alert-cancel-btn');

            // Assign onclick handlers
            confirmBtn.onclick = () => {
                closeModal('alert-modal');
                if (onConfirm) onConfirm(); // Execute the confirm callback
            };
            cancelBtn.onclick = () => {
                closeModal('alert-modal');
                if (onCancel) onCancel(); // Execute the cancel callback if provided
            };

            openModal('alert-modal');
        }

        // --- Urdu Font Handling ---
        /**
         * Checks if a string contains Urdu characters.
         * @param {string} text - The text to check.
         * @returns {boolean} True if Urdu characters are present, false otherwise.
         */
        function hasUrdu(text) {
            // This regex covers the main Urdu Unicode block
            return /[\u0600-\u06FF]/.test(text);
        }

        /**
         * Recursively walks through the DOM starting from `node`.
         * If a text node containing Urdu characters is found, it wraps it in a span
         * with the class 'urdu-font-force' to apply the Noto Nastaliq Urdu font.
         * @param {Node} node - The starting node (e.g., document.body).
         */
        function wrapUrduTextNodes(node) {
            // Skip nodes that shouldn't be processed
            if (!node || node.nodeType === Node.COMMENT_NODE || node.tagName === 'SCRIPT' || node.tagName === 'STYLE') {
                return;
            }

            // Process Text Nodes
            if (node.nodeType === Node.TEXT_NODE) {
                // Check if the text node contains Urdu and hasn't already been wrapped
                if (hasUrdu(node.textContent) && node.parentNode.className !== 'urdu-font-force') {
                    const span = document.createElement('span');
                    span.className = 'urdu-font-force'; // Apply the class for font styling
                    span.textContent = node.textContent; // Move the text content to the span
                    node.parentNode.replaceChild(span, node); // Replace the text node with the styled span
                }
            }
            // Process Element Nodes recursively
            else if (node.nodeType === Node.ELEMENT_NODE) {
                // Check if the element itself should be forced (e.g., if language is Urdu)
                // This might be too broad, wrapping text nodes is usually safer.
                // if (currentLanguage === 'ur') {
                //     node.classList.add('urdu-font-force');
                // }

                // Recursively process child nodes
                // Convert childNodes to an array to avoid issues if the list changes during iteration
                Array.from(node.childNodes).forEach(child => wrapUrduTextNodes(child));
            }
        }


        // --- Initialization ---
        // Use DOMContentLoaded to ensure HTML is parsed before running scripts
        document.addEventListener('DOMContentLoaded', async () => {
            try {
                await initDB(); // Initialize the database first
                setupForms(); // Setup form submission listeners
                setupEventListeners(); // Setup button click listeners etc.
                setLanguage(currentLanguage); // Apply initial language (from localStorage or default)
                await loadCustomers(); // Load initial customer list
                await updateDashboard(); // Update dashboard summary
                showCustomerListView(); // Ensure the app starts on the customer list view
                console.log("Application initialized successfully.");

                // Initial application of Urdu font after everything is loaded
                wrapUrduTextNodes(document.body);

            } catch (error) {
                // Handle critical initialization errors (e.g., IndexedDB failure)
                console.error("CRITICAL: Initialization failed:", error);
                // Display a user-friendly error message covering the entire page content
                document.body.innerHTML = `<div style="padding: 20px; text-align: center; color: red; border: 2px solid red; margin: 20px; font-family: sans-serif;">
                    <h1>${getLang("Initialization Failed")}</h1>
                    <p>${getLang("Could not initialize the application database.")}</p>
                    <p>${getLang("Please ensure you are not in private browsing mode and that your browser supports IndexedDB.")}</p>
                    <p><i>${getLang("Error details:")} ${error.message || error}</i></p>
                    <p style="margin-top: 15px;">${getLang("Try refreshing the page or clearing browser data if the problem persists.")}</p>
                    </div>`;
            }
        });

    </script>
</body>
</html>
